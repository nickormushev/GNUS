Понеже се допитах до колежка по-долу: тя е Ирина Куртева и кара курса в момента. 81831
е факултетният й номер. Не знам дали се водим отбор заради това, защото цялостно работихме разделно
с изключение на jpeg-turbo проблема ми. Там преценете дали ще ни водите отбор. Май тюленбус решихме
да е името ни. Не знам защо се навих XD.

След прочитането на задачата ми изглежда доста интересна. На пръв поглед си мисля, че няма как да е
свръх трудно да инсталирам неща от source. Вероятно процеса ще включва доста четене, за да разбера
за какво са отделните пакети и как да ги навържа, но пък мога и да греша. 

Като начало реших да прочета какво е phpinfo(), защото не съм писал нищо свързано с php досега и не
знам какво прави тази команда. Видях, че изписва конфигурацията на php и разбрах, че съм пропуснал
да забележа, че и това ще трябва да го инсталирам. Линк: https://www.php.net/manual/en/function.phpinfo.php

Реших да тръгна по пакетите в реда, който са дадени. Като начало преди да инсталирам каквото и да
било вероятно ще е добре да прочета всеки от тях от какво се нуждае и от какво зависи, за да мога да
преценя с кой да започна процеса на подготвяне на системата.

zlib:
Научих, че това е библиотека за компресиране на данни. Тя е lossless, което предположих, че
означава, няма загуба на информация при компресиране, ама проверих в wikipedia за всеки случай дали
съм прав. Разбрах също така, че не разширява(expand) данните преди да ги компресира за разлика от
стандартните алгоритми за компресиране на UNIX, които използват LZW compression. Като цяло не
съм наясно с алгоритми за компресиране и как работят. Вероятно е интересна тема, ама не съм
задълбавал по една или друга причина, така че не знам как zlib премахва разширяването на данните, но
все пак звучи готино особено, ако нямаш много място. Разбрах, че zlib се използва от Java JDK и също
така, че е много важна част за libpng, което ми казва, че е важно да го инсталирам преди libpng
пакета. Погледнах, че libpng и zlib вече ги имам инсталирани на системата си. Понеже не искам да си
чупа dependency-тата няма да ги трия, а ще използвам абсолютни пътища до генерираните от мен бинарни
файлове при инсталацията от source. Това вероятно ще го направи интересно да кажа на libpng да
използва моя пакет, а не създадения от системата. Вероятно е някаква опция, която трябва да открия.
В този manual: https://zlib.net/manual.html е описоно, че zlib не е за компресиране на отделни
файлове, а за компресиране на данни от паметта или за комуникационни канали. 


libpng:
Поглендах тази страница за libpng: http://www.libpng.org/pub/png/libpng.html . Видях, че е reference
library за PNG и се замислих, че не знам какво е reference library. Гугълнах малко и стигнах до
уикипедия, което ме насочи към дефиницията на reference implementation, което доколкото разбирам е
някаква първоначална имплементация на някакъв стандарт(примерно PNG), по която трябва да се водят 
всички други имплементации. Примерна имплементация все едно. От това заключих, че libpng е
имплементация на стандарт за работа с png файлове. Поне така го разбирам. Не съм на 100% дали съм
прав. Последвах и линка пратен към github-а на libpng, където намерих файл, описващ как да се
инсталира, кръстен INSTALL: https://github.com/glennrp/libpng/blob/libpng16/INSTALL. 
Също така на поне 100 места пишеше, че е добра идея да инсталирам първо zlib.

Изглеждаше ми безобидно да започна с инсталацията на zlib. Доколкото виждам не зависи от нещо друго
и просто компресира и декомпресира файлове. Съмнява ме, че има някакви опции специфично нужни на
libpng или някой друг софтуер. Понеже миналата година карах курса на hackman бяхме засегнали темата
за build-ване от source и реших да прегледам записките си от тогава и презентацията, която той беше
качил:
https://github.com/hackman/linux-sysadmin-course/blob/master/presentations/linux-software-installation.odp
Презентацията не е много подробна, но неща като правилата на Francois Picard имам чувството, че бая
ще ми помогнат. Също така си припомних, че има autotools(automake, autoconfs), с които може да ми се
наложи да си генерирам configure script-а и Makefile-а. Прочетох малко за тях тук:
https://developer.gnome.org/anjuta-build-tutorial/stable/create-autotools.html.en
Понеже горния линк не ми обясни много добре нещата потърсих още малко и намерих това:
https://www.gnu.org/software/automake/manual/html_node/Creating-amhello.html#Creating-amhello
Спомних си, че configure.ac и Makefile.am са файловете, в които описваме какъв configure скрипт и
какъв Makefile искаме да се конфигурира. Съответно с тях генерираме Makefile.in configure.h
configure и src/Makefile.in, които са темплейтни. Информацията в тях се замества след като пуснем
./configure с желаните от нас опции и се генерира вече крайния Makefile.

Свалих zlib source-а и го разархивирах и видях веднага, че се използват autotools. Makefile-а още не
беше генериран. Трябваше да започна с configure и по-точно с ./configure --help . Също така си
създадох build.sh, в който реших да си записвам опциите, с които съм build-нал пакета. Пакетите са
доста и има голяма вероятно да забравя точно какво съм въвел, а и Хакман ни повтори поне 300 пъти
колко е важно да се прави това.

Преди да започна да започна да се мъча с configure се усетих, че имаше едно също толкова важно
правило и това е винаги да се чете README файла. Аз разбира се бях на път да направя грях за света
на системната администрация, но днес не беше ден на дявола и за щастие се усетих, че вероятно е
добра идея да не бързам да правя глупости и устоях на изкушението. На този ден аз взех разумно
решение, защото беше написано, че е добра идея да прочета в Makefile.in за инструкции как да си
build-на пакета. В него за жалост нямаше нищо полезно различно от ./configure; make test; make
install, което го знаех.

Все още не бях доволен да започна с build-а. Опциите на configure не ми говориха нищо освен prefix
опцията, която знаех, че казва къде да се build-не и някои други явни опции, катоа архитектура,
което не мисля, че е нужно да задам експлицитно. Започнах да търся документация на тези опции.
Изглеждаха ми стандартни и не специфично за zlib, а по-скоро генерирани от autotools и затова търсих
в гугъл(все пак се опитах да намеря и някаква документация на zlib).

В процеса открих, че configure си генерира configure.status с последния build и горната идея за
shell script с какви опции съм подал ми изглеждаше малко по-безсмислена, ама пак реших, че поне
по-лесно ще се чете, ако е с 200 опции.
https://www.gnu.org/software/autoconf/manual/autoconf-2.67/html_node/config_002estatus-Invocation.html

Намерих някои generic flag-ове на този линк: https://www.gnu.org/prep/standards/html_node/Configuration.html
Тук беше описан синтаксис за пускане на feature-и, избиране на архитектура и избиране на директории
за слагане на файлове.

В един от файловете също пишеше, че има статично и динамично build-ване на библиотеки. Прочетох тук:
https://medium.com/@StueyGK/static-libraries-vs-dynamic-libraries-af78f0b5f1e4#:~:text=Static%20libraries%2C%20while%20reusable%20in,outside%20of%20the%20executable%20file.&text=In%20contrast%2C%20a%20dynamic%20library,a%20need%20to%20re%2Dcompile.
че динамичното build-ване разделя библиотеките в отделни so обекит, докато статичното ги добавя в
готовата бинарака. Бонус на първото е, че много приложения използват еднакви библиотеки и така ги
имаме по веднъж, както и че по-лесно се правят промени по-тях. Минус на първото е, че по-лесно се
чупи и програмите ти зависват. В zlib може да пусна статчино компилиране със --static и затова
проучих горното.

Повечето флагове бях вече наясно за какво са освен zprefix, eprefix и някои от dir флаговете, които
мисля, че се подразбираха, ама реших да проверя.

За includedir и другите dir флагове за определяне на директории намерих този ресурс, който описва
всичките, които аз намерих поне: https://www.gnu.org/prep/standards/html_node/Directory-Variables.html

eprefix видях, че е кратко за exec_prefix в configure файла и намерих полсе това:
https://www.gnu.org/software/gnats/doc/gnats-4.1.999/html_node/exec_002dprefix.html#:~:text=exec%2Dprefix%20corresponds%20to%20the,gnats%20user%20tools
От прочетенето разбрах, че това отделя host dependant бинарките от тези, които не зависят от него.
Така може със символични връзки да се използват същите файлове от различни host-ове и да няма дупликация
на пакети.

zprefix е нещо специфично на zlib, което добавя префикс на библиотеките и типовете на приложението.
Това не знам кога би било полезно. Може би, ако съвпадат с някои на твоята система, но все пак в
ситуацията ми е безсмислено. Тази информация намерих като разглеждах source файловете в zconf.h

Има още един const флаг, който не намирам за какво е. Доколкото видях променя как третира константи
в код, но местата, на които го открих не бяха официална документация и ми изглеждаха съмнителни.
След малко гугълване открих това:
https://stackoverflow.com/questions/43046020/zlib-1-2-11-configuration-options , което общо взето
каза, че const не е документирано, но че прочетеното от по-рано е вярно и пуска const като ключова
дума за параметрите на zlib функции доколкото разбирам. Абе не ми трябваше и си загубих времето да
го търся, ама поне вече знам. Тук са по-малко флаговете, но вероятно ще започнат да растат
експоненциално и няма смисъл да се вманичавам, като при kernel-а.

Като следваща стъпка най-накрая build-нах от source zlib. Направих configure като добавих prefix
само, за да избера папка под /opt. make test, за да видя, че всичко е наред и make install за
завършек. Отидох да разгледам какви файлове са се генерирали. Имаше c header файлове, завършващи на
.h, който предполагам моята програма би include-нала при стартиране. Имаше и .so файлове, които бяха
самите библиотеки. Като цяло обаче не бях сигурен точно кога и къде се добавят тези so файлове и
точно какво са. За това се обърнах към гугъл и видях как да си ги направя. Спомних си, че съм учил,
че линкера ги добавя в кода, когато се link-ва програмата и се получава крайния резултат. Този линк
беше полезен да видя как .o файловете получени при компилация се превръщат в .so файлове и да
осмисля малко повече процеса: 
https://www.thegeekstuff.com/2012/06/linux-shared-libraries/#:~:text=Shared%20Libraries%20are%20the%20libraries,by%20any%20number%20of%20programs.

Като завършек след около 3 час build-нах zlib. Май е добре да го карам малко по-уверено и да не съм
толкова перфекционист, така че да разбирам всеки флаг. Тук все пак и навлизах малко и затова също
отне повече време, прекарано в четене. Надявам се нататък да съм една идея по-бърз.
Сега ще продължа напред с четене за някои от другите библиотеки и програми, които ще ми се наложи да build-на. 

libjpeg-turbo:
Това е библиотека за компресиране и декомпресиране в jpeg формат: https://libjpeg-turbo.org/Main/HomePage 
Използва SIMD(Single instruction multiple data), за да забърза процеса на работа и съм щастлив да
кажа, че знам какво означава това. SIMD го учихме по КАРХ и доколкото си спомням хардуера работи с
все едно с масиви от данни наведнъж. Вместо да сумира клетка по клета паралелно сумира 20 клетки
примерно. 

На пръв поглед libjpg-turbo няма dependency-та, ама може нещо да пропускам. Ще сваля първо файловете
ще прочета README-то и ще се надявам да съм прав :D. Намерих този линк на официалното github repo
как да build-на libjpg-turbo. Като гледам е със cmake, с което имам по-малко опит, но ще прочетем и
ще видим дали е по-тегаво.

Разгледах README-то и имаше доста информация. Примерно забелязах, че libjpeg-turbo е базиран на
версия 6b на libjpeg. Ако другия софтуер, който build-на, работи с по-нова версия ще трябва да сложа
съответните флагове за версия 7 или 8. Версия 9 май не я харесваме много много XD. Има и различни
extension-и за други colorspaces. Не разбирам достатъчно да кажа дали ще ми трябват. Към момента
залагам на не, ама знае ли човек. Също така видях, че има и BUILDING.md, който описва как да си
build-нем библиотеката.

Преди да мина към четене как да build-на разгледах каква е разликата между libjpeg-turbo и API-то ми
TurboJPEG. Разбираемо е защо може да се обърка човек между двете. Иначе API-то очевидно определя как
изглеждат функциите и какви методи има библиотеката, а libjpeg-turbo е самата библиотека. Линк:
https://libjpeg-turbo.org/About/TurboJPEG 
Покрай горната тема прочетох и за това какво е wrapper library, защото TurboJPEG така е дефинирано.
Това явно е библиотека, която променя вида на API-от на самата библиотека с цел опрсотяване или
съвместимост. Източник wikipedia wrapper library(линкът е дълъг и грозен и реших да не го слагам
тук)

Като начало проверих дали лаптопа ми поддържа SIMD. Погледнах SSE instruction set-а дали го има в
/proc/cpuinfo. Понеже не знам всичко за линукс тази информация намерих тук:
https://www.mathworks.com/matlabcentral/answers/93455-what-is-the-sse2-instruction-set-how-can-i-check-to-see-if-my-processor-supports-it
Ето и линк за SSE: https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions . Да не повярва човек
поддържа го. Вече нямам извинение да не го използвам при build-ването на libjpeg-turbo.

BUILDING.md-то започва с dependency-та като cmake, което имам инсталирано и NASM или YASM за SIMD,
които ме вдъхновиха за горната секция. За щастие manjaro-то ми имаше nasm в package manager-а си и
го инсталирах лесно :). Другите dependency-та бяха gcc и jdk, които имам. jdk е нужен само в случай,
че ще го използвам с java и вероятно няма да се наложи, но го имам по други причини така или иначе.

Обаче стана късно и ще спя. Така, че ще продължим следващия път на Ники е написал 175 реда и е
build-нал само една библиотека.

На другия ден прочетох BUILDING.md и видях какви файлове генерира. Още .so файлове са и бях учуден,
че има API и за libjpeg и за TurboJPEG. Прочетох пак линка и видях, който бях сложил горе и осъзнах,
че TurboJPEG wrapper-а използва libjpeg отдолу и също така библиотеката просто поддържа и двете,
защото по-лесно се реализира. Явно съм бил уморен и съм го пропуснал.

Също така разбрах, че има няколко начина да инсталирам jpeg-turbo. Мога да създам deb или rpm пакет,
който послед да използвам. Мога със cmake да build-на приложението, а мога и с make install да го
инсталирам подобно на миналото. Готино е, че поддържа ccmake и cmake-gui, с които мога да избирам
опции, с които бих искал да build-на приложението си. Едното е ncurses базирано другото си е с цял
GUI. Като цяло това е мега готино и не се налага да търся 300 години в различни файлове за какво са
различните опции. Цялостно jpeg-turbo е мега добре документирано. Разделено е на нива и е обяснено
кое за какво е. Абе повече ми харесва на пръв поглед от zlib. Не мога да кажа категорично, като не
съм задълбал, но някакси по-подрбоно излгежда.

Като си поиграх малко с командите осъзнах, че не съм разбрал правилно. Първо трябва да build-на
makefile-овте със cmake, като мога да му подам опции. В последствие мога да инсталирам с make
install и прочие, използвайки генерираните файлове. Явно нещо съм се объркал. Интерсно е, че на
няколко места реферират source directory и build directory като две различни неща и доколкото аз
разбрах сваленото от гитхъб е source-а. Проблем е, че там команди като ccmake и cmake-gui не ми
работеха противно на документацията, където пише, че тази директория трябва да се използва. source
directory-то трябва да е първоначалното, защото така е описана cmake, която генерира build
директорията, къдет работят ccmake и cmake-gui. Може те нещо да са объркали, а може и аз да съм.
Силно се надявам, че не изпускам нещо. 

След build-ване на инсталационните файлове използваха make test и за мое съжаление не мина :( .
Реших да разгледам ccmake да видя дали не е проблем с конфигурацията, макар че не ми се вярва.
Казваше, че djpeg е дало segafault някъде. ccmake ми харесва. Удобно е. Понякога описанието излиза
извън екрана ми обаче и не знам как да го дочета. Имаше и advanced опции за компилатори и линкери.
Мога да кажа и къде да търси dependency-тата си. Имаше и доста инфо за създателите, версии и опции
като подръжка на java и използване на SIMD, ама не ми изглеждаше като от там да е проблема. След
проваления test реших все пак да компилирам и взе, че тръгна. Пуснах го на ръка да видя дали djpeg и
cjpeg работят. Свалих jpg файл и използва djpeg. След като получих епилепсия и се чудих какво излиза
се усетих, че трябва да redirect-на output-а във файл. После проверих типа на файла и видях, че вече
не е jpeg. После пак го компресирах успешно до jpeg. Изглежда като да работи. Още е мистерия за мен
защо make test се провали. Притеснява ме, че вероятно е важно, ама има контролно събота и нямам
време да задълбавам.  Опитах се да открия къде е source кода и кой тест се проваля, ама не го
открих. Ако остане време ще го погледна. 

Пуснах make test още веднъж след make install и минаха. Явно за разлика от zlib тези тестове
изпорбват генерираните файлове(бинарките, библиотеките и тн). Това леко ме обърка, но предполагам е
логично да тестваш дали това, което се е генерирало работи. Така или иначе успях най-накрая да
build-на и втората библиотека. Не съм слагал някакви по-специални опции. Генерирах го с тези по
подразбиране. Само смених папката.

libpng:
Най-накрая свалих libpng и отворих да прочета README-то и INSTALL.md файловете. В README-то имаше
повече историческа информация. Не намерих нещо свръх полезно. Може би, че препоръчват zlib версия
по-нова от 1.4, но аз свалих най-новата, така че тук не би трябвало да имам проблеми. В INSTALL.md
файла беше описано как да подам директорията, в която съм инсталирал zlib. Работеше със environment
variables и реших да видя дали няма тези опции и в ./configure, за да мога по-лесно да ги опиша в
build.sh файл. Не, че export-тите не мога, ама така като, че ли би било по-чисто. Препоръчително е
zlib и libpng са в съседни директории. Това беше плана така или иначе,т.е. и тук нямах проблеми.

Разгледах ./configure --help, което беше много добре описано. Обяснено беше всяка опция за какво е
за разлика от zlib. Понеже флаговете --build и --host ме объркваха реших да гугълна, да разбера
каква е разликата. Намерих това: https://gmplib.org/manual/Build-Options , от което разбрах, че
първото казва на каква система ще се build-не, а второто на каква система ще се използва.
Намерих и този линк: https://www.gnu.org/software/automake/manual/html_node/Cross_002dCompilation.html
на който прочетох и за target, което казва за каква система compiler tools трябва да се build-нат.

В configure опциите намерих опции за директории, за създаване на symbolic links без версии за
различните .so файлове и подобно. Намерих и --with-zlib-prefix, което ми изглежда като това, което
искам за да му кажа къде да търси zlib и тук е много удобно това, че си създадох build.sh файл, в
който имам точни път, който използвах. Имаше и няколко envoronment променливи, който overwrite-ват
configure, като LDFLAGS за линкера и CC и тем подобни. 

Флаговете за ./configure, който използвах в крайна сметка бяха само за zlib prefix и prefix просто.
Другите ми се сториха ненужни или бяха пуснати по подразбиране, като тези за symbolic links. Пуснах
си build.sh скрипта и после направих make check, както се препоръчваше в INSTALL.md. Всички libpng
тестове минаха :D. Пуснах и make test, за да съм на 100%, че всичко е ок и след малко ще пусна make
install.

Спомних си, че миналата година бяха учил, че е добра идея да правя make преди make install, но не си
спомнях какво make само прави. Намерих това:
https://stackoverflow.com/questions/16637860/why-make-before-make-install#:~:text=make%20without%20parameters%20takes%20the,them%20on%20the%20current%20computer.
Явно make пуска първият target и той в повечето случай е за компилиране. make install после го
инсталира. Цялостно засега INSTALL.md-тата не са казвали, че е нужно да пиша make и в stackoverflow
линка пише, че в повечето случаи едното зависи от другото и се пускат и двете. Все пак може да е
добра идея да го имам предвид, но все пак INSTALL.md ми изглежда, като най-достоверния източник на
информация. 

Исках да тествам по някакъв начин zlib и libpng. Успях да пусна make test с моят zlib, като следвах
инструкциите от INSTALL.md-то. Тестовете минаха и считам, че правилно съм наконфигурирал libpng.
Нямма много време за губене още на това дали всичко работи. Пуснах pngfix на едно png и то каза, че
е ок и не изгърмя. Надявам се това да е достатъчно, макар че не съм го използвал със zlib. Абе ако
се счупи нещо ще знам, че може да е това.

Намерих make installcheck, което се опитах да пусна, но за жалост не ми се получи. Каза, че няма
какво да прави нищо, че го намерих в Makefile-а. Вътре обаче не беше дефинирано.

libgd:
Като първа стъпка му свалих source кода. Надявам се в него да има README.md, което да ми каже за
какво се използва. Реших все пак да хвърля едно око на сайта и видях, че gd=graphics draw. Това е
библиотека за рисуване на изубражения и резултатът е jpeg или png:
http://libgd.github.io/manuals/2.3.0/files/preamble-txt.html

Отворих след това README.md файла и започнах да чета. Също така видях пак, че под docs има INSTALL
файл. Доста удобни са тези 300 файла :D. Иначе залагам, че libgd ще използва libpng и libjpeg,
защото това е формата на генерираните от него изображения и също така четох, че има wrapper за php.
Много интересно взе да става :D.

В README.md показваше, че libgd има поддръжка за libjpeg-turbo и libpng. Случайност?? Не мисля!! Тук
има някаква конспирация. Иначе преди да продължа видях, че искаме поддръжка за нещо наречено
freetype. Понеже не знаех какво точно е това потърсих из страниците на libgd. Най-накрая намерих
линк на github-а им към https://freetype.org/ . Явно рендерира шрифтове. Интересно. В секцията
overview имаше по-подробна информация, че рисува глифи и може да се ползва като font conversion
tool или за генериране на текст. Видях, че freetype се нарича и freetype2 и също така намерих пакет
за manjaro с това име, който е за растерна графика и е свързан със шрифтове. Заложих, че е същият и
реших да го инсталирам. 

INSTALL файал се оказа generic, но до него имаше README.txt с информация за флагове и как да пусна
freetype и други препоръчителни библиотеки като jpeg, libpng и тн. Препоръчително беше да инсталирам
libxpm и реших да го сложа. Реших все пак да си записвам какви пакети инсталирма, да ги изтрия
после.

Прегледах ./configure --help и изглеждаше общо взето като libpng с малки разлики. Важните опции за
freetype, libpng и другите вече ги бях намерил в README-то, но и тук ги имаше. Другите опции не ми
изглеждаха важни. В крайна сметка добавих всички библиотеки свалени до сега от zlib до libjpeg-turbo
+ freetype + xpm. 

libpng:
В този момент се усетих, че libpng инсталацията ми е грешна. --with-zlib-prefix е за функциите и
методите, а не къде се намира zlib. С други думи не ми върши работа :( и инсталацията ми използва
грешното zlib. Разбрах, че трябва да сменя LDFLAGS и CPPFLAGS, така че по време на build linker-а и
компилатора да търсят в правилната директория. Също така разбрах за LD_LIBRARY_PATH, където linker-а
търси за библиотеки: https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html . Така
with-zlib-prefix беше премахнато и с тези променливи(Копирах ги от INSTALL) пак направих make и make install:

ZLIBLIB=/opt/h5/zlib/lib export ZLIBLIB
ZLIBINC=/opt/h5/zlib/include export ZLIBINC
CPPFLAGS="-I$ZLIBINC" export CPPFLAGS
LDFLAGS="-L$ZLIBLIB" export LDFLAGS
LD_LIBRARY_PATH="$ZLIBLIB:$LD_LIBRARY_PATH" export LD_LIBRARY_PATH

Тези променливи ги сложих в install.sh скрипт с make, make test, make check и make install накрая,
за да знам какво съм правил. Като пуснах script-а осъзнах, че make test == make check и само си губя
времето като пускам и двете и затова махнах едното. Вече, като оправих lipng можем да се върнем към

libgd:
Та последно го наконфигурирах и различния ./configure ми подсказа за грешката в libpng. Пуснах make
и make check, но make check се провали. Реших, че може нещо да съм объркал в някоя библиотека, ама
всички тестове иначе минаваха. Намерих, че версията на libjpeg ми е 80, а очаква 62. Аз обаче
компилирах 62 и не знам защо това е проблем.

Дебъгвах твърде дълго тази глупост. Още не съм разбрал какъв е проблема. Смята, че версията на
libjpeg-turbo e 80,но навскякъде е 62. Library файловете са версия 62.0.3. Конфизите показват, че
съм компилирал версия 62. Опитах се да махна бонусите, който libjpeg-turbo добавя, да видя дали не
са проблемни, но не е и това. Една колежка със същите стъпки успя да подкара на нейната машина libgd
и тестовете да минават. Еднакви версии на софтуера използвахме. Не знам какво може да е. 

Прекарах близо 3-4 часа да мъча да подкарам версия 62.0.3 на libjpeg-turbo да работи с libgd и цялостно
ми писна. Не измислих къде е проблема. Доколкото разбирам има някакво разминаване между версията, която
се рекламира и тази, която се води libjpeg. Не знам това как е възможно и интересното е, че при колежката,
която питах това не беше проблем. Не е като libgd да поддържа само по-новата версия, а и то технически
не е точно по-нова версия. В крайна сметка просто build-нах libjpeg-turbo с емулация на libjpeg версия 8.
Вече всички тестове минаваха без един, който като погледнах ми изглеждаше, като off by one error. Беше
299 вместо 300 на едно място, а всички други полета съвпадаха. Може и аз да бъркам, ама не ме тревожи толкова.
Най-накрая build-нах. Изнервен в 2 през нощта. И ще си лягам. Дано времето утре ми стигне да оправя 
другите пакети и да няма повече такива проблеми.

apr:
На другия ден продължих напред с apache portable runtime. Отидох и прочетох за какво се използва.
Доколкото разбрах идеята е да предостави API за даден софтуер, такова че да не се влияе софтуер-а от
това в каква среда работи. С други доми дали си на Intel или на ARM примерно не е от значение API-то
на apache portable runtime ти позволява да имаш същите endpoint-и и да работи по един и същи начин,
което е готино. https://apr.apache.org/ . После погледнах документацията, която ми изглеждаше
славнително безполезна само за build. Визирам тази на doxygen. Там бяха изредени функциите на apr-а.
После видях, че има build секция: https://apr.apache.org/compiling_unix.html и я разгледах. Общо
взето беше безполезна. Пишеше само ./configure make make install, което вече го наизустих :D. След
това свалих пакетите(главния и utility). Понеже нямах точна дефиниция на utility software в главата
си реших да го гугълна: https://en.wikipedia.org/wiki/Utility_software . Знаех, че software
utility-тата са по-скоро администраторски пакети за мониториране, анализа, проверка за изправност и
подобно, но реших все пак да си потвърдя дефиницията. 

Влезнах в APR директорията след като го свалих и като първа работа се опитах да видя дали има
файлове за инсталацията. За жалост нямаше. Имаше README обаче, така че започнах с него, както
винаги. Май трябва да спра това да го описвам за всеки нов софтуер. Мисля, че трябва да се
подразбира вече :D.

След четене на README-то видях, че софтуера симолира операции на операционната система, като
алокиране на памет, file and network I/O, mutex-и и тем подобни. Явно идеята е, че APR-а знае как да
извърши тези операции на всякаква операционна система и така може програмиста да пише кода само
веднъж. Пишеше, че http сървъра използва APR-а. Имаше опции как да тества пакета, че работи и
пишеше как да инсталирама пакета на UNIX, windows и как да генерирам rpm. Цялостно нямаше много
полезна информация. Може би, че мога със ./testall -v да пусна verbose вариант на всички тестове. За
опции пишеше да прочета ./configure.

Прочетох за gnu ld: https://linux.die.net/man/1/ld, което явно е линкера на гну. Научих и какво е
apache subversion(version control система на apache). Прочетох и какво е PIC object: 
https://en.wikipedia.org/wiki/Position-independent_code . Явно е код, който без значение от къде го
пускаме пак ще даде същия резултат. Обратното е absolute code, който няма да работи, ако го пуснем
на различно място в паметта. Има и load-time-locatable код, който линкер мести преди да го пусне, за
да работи правилно. libtool - научих, че е софтуер, който се използва за компилиране и инсталиране
на библиотеки. Научих каквое е electric fence: https://elinux.org/Electric_Fence . Той засича за
грешки при заделяне на памет(malloc). Някакъв софтуер се опитва да достъпи памет или да пише в памет,
която не е заделена или не е негова. Научих и какво е egd: http://egd.sourceforge.net/ . Явно
софтуер за събиране на информация, която после да може да се използва при генериране на random
числа. Тази информация май се нарича entropy.

Повечето опции на ./configure засягаха термините от горната секция. Също имаше доста опции за debug
използване на mmap вместо malloc, UNIX shared memory, махане на dso файлове и тн. Цялостно доста
опции, но като гледам нито една не ми е от полза в ситуацията. Инсталирах apr с познатата поредица
от команди и тестовете минаха.

apr-util:
както apr е за работа с операционната система и хардуера, като I/O shared memory и подобни, apr-util
е за работа с библиотеки. Идеята му цялостно е същата. Консистентно API без значение какви
библиотеки има инсталирани на системата и с какви библиотеки работиш. Примерно няма значение дали ще
инсталираш libjpeg или libjpeg-turbo, ако считаме, че API-тата им са различни. apr-util ще работи с
тях, а ние имаме консистентно API. Примерно има и поддръжка за SSL до различни типов ldap без
значение дали openldap, 389ds или нещо друго. Има memcache, queue-та и xml-parsing, както и много
други, които не ми говорят много. Ако остане време ще ги разгледам и тях.

Тук нямаше опсиание на инсталацията, но считам, че е същото като при apr. Затова реших да разгледам
configure. Тук имаше много опции за различни бази данни, като postgres, mysql и подобни. Също ldap
опции и алгоритми за криптиране и хеширане като sdbm и подобни. Имаше и опция да му кажа да работи 
с apr, което вече инсталирах, така че това е добра идея да го добавя. Явно разбирането ми може би е
било леко грешно. Към момента ми изглежда като това да помага за работа с различни бази и системи като
ldap? Може би аз се бъркам де, но не виждам защо би му трябвало ldap repository на apr-util. За база
също не съм убеден, ако главно мап-ва endpoint-и и не пази информация, а и това са optional
package-и уж, т.е. би трябвало и без тях да работи. Поддържа и интефейс за работа с различни
криптиращи алгоритми. Явно не е точно за библиотеки както си мислех. Засега като опция ще му сложа
само apr. Имам локална инстанция на postgres, но предполагам няма да ми трябва. Пуснах make и make
test всичко мина ок и инсталирах. Следваща стъпка httpd :D. Там помня, че опциите бяха бая.

apache httpd:
Тук вече знам какво е httpd. Преди съм учил как се конфигурира web server и наскоро ми се наложи да
правя промени по конфигурация на httpd сървър, ама беше просто един RewriteRule. Цялостно съм
позабравил нещата, но не мисля, че бяха свръх сложни, но бяха много, а и apache май имаше 30000000
plugin-а и addon-а, които могат да се сложат да го extend-ват за различни случаи. Свалих директно
пакета и прочетох README-то, което сочеше към документацията на httpd и обянсвяаше как httpd
използват криптографски софтуер и, че има INSTALL.md файл, в който е описано как се инсталира.

Прочетох INSTALL файла. Общо взето обясняваше, че препоръчва да има apr и apr-util инсталирани(какво
съвпадение :D) и също така специфики за mac и freebsd. Имаеш и примерна инсталация и линк към
по-подрона документаиция: http://httpd.apache.org/docs/2.4/install.html . От requirements нямах само
pcre, а perl интерпретатор имах инсталиран, така че реших да го използвам щом се препоръчва за някои
скриптове. Освен requirements другите неща бяха същите като при другите пакети.

./confugure прегледах. Доста по-дълго от тези досега както очаквах. Бързо открих with-apr и
with-apr-util опциите, които са важни. Погледнах какво е suexec: https://linux.die.net/man/8/suexec
Явно мога да настроя apache-а да си сменя потребителя, когато вика някоя програма. Тук се вижда
термина CGI, което доколкото знам е web server-и, за да могат да си комуникират с приложения. Все
пак реших малко повече да прочета за CGI в уикипедия, но не задълбах много. Не знам защо имам
чувството, че ще имам лекция за httpd и CGI така или иначе, макар че мога и да греша. 

Optional feature-ите на apache-а са бая. Видях функционалности от сорта на rewriteRule-а да го пусна
за reverse proxy, пускане на suexec, cgi скриптове, дори поправяне на правописни грешки, което не
знам колко е надеждно, но на идейно ниво е готино. Мога и всички модули на веднъж да заредя, което
май не е супер добра идея XD. Имаше бая опции за authentication и authorization, като ldap,
groupfile, file based и други. Не съм задълбал във всичките, ама изглежда, че каквото и да ти трябва
го има. Имаше доста видове кеш и различни филтри, като ме учуди, че даже и sed може да се използва
за филтриране. Очеивдно може да се конфигурира да е proxy и да се зареди proxy module за http и ftp
и много други, които не съм чувал. Щеше ми се да разгледам по-подробно всички опции и вероятно доста
бих научил, ама честно казазно след кърнъла малко ми е писнало от опции за ето този частен случай
или точно този софтуер. Затова няма повече да задълбвам. Като гледам само --prefix да бях сложил
стига, така че вероятно важната част от модулите са си пуснати по подразбиране. Добавих само
пътищата към apr, apr-util и zlib. Сега ще направя configure, make и make install. 

След инсталацията отидох на localhost:80 и излезна It works!. Този път всичко мина плавно, поради
което съм много щастлив. Остана само php :D.

php:
php знам, че е скриптов език за програмиране. Свалих му последната стабилна версия от php.net.
Прочетох README-то и общо взето процедурата е ясна. Има make test и мога да използвам -j. Вероятно и
преди е могло, ама аз съм тъп и забравих за този флаг. Вероятно бая време щеше да спести. Сега, като
ме е боляло веднъж се надявам да го запомня.

Разглеждането на ./confugure . Една от първите опции след default-ните споменава apache apxs и
гугълнах да видя това какво е: https://httpd.apache.org/docs/2.4/programs/apxs.html и а познай това
build-ва модули за httpd. Това явно е това, което ще използвам, да build-на php като модул. Също
така никъде другаде не се спомена Apache, така че други опции не виждам XD. Реших да погледна и
какво е SAPI, защото тази опция е под секцията с това име и намерих:
https://stackoverflow.com/questions/9948008/what-is-sapi-and-when-would-you-use-it
Server API на php. Това се използва за комункиация между php и httpd. Май е навързона със CGI-а или
е самия CGI. Аха от тук видях, че има: https://www.php.net/manual/en/features.commandline.differences.php
CGI SAPI и CLI SAPI. Това наистина е връзката със сървъра и е CGI-а, с който си комуникират. 

Погледнах какво е PDO: https://www.php.net/manual/en/intro.pdo.php - Generic драйвер/интерфейс за работа с
бази, който има специфични разновидности на база с коя баз искам да работя.

DBA: https://www.php.net/manual/en/intro.dba.php - поддръжка на berkley бази данни, за които не бях
чувал. Потърсих в уикипедия малко, ама не задълбах. Имаше поддръжка за част от библиотеките, които
инсталирахме, като libjpeg и freeptype(които добавих). Секюрити неща, като kerberos, хеширане,
компресиране(zlib, което също добавих). Имаше и неща, като поддръжка на SOAP формата, сокети и доста
други интересни опции. Като се змаисля не знам дали има смисъл да разписвам опциите. Разписвам
главно тези, които знам за какво са или поне част от тях. Може наистина да е било безсмислено, ама
искам да видя какво има и понякога задълбавам.

След четенето направих make make test и make install. Малка част от тестовете се провалиха, но
доколкото разбрах не е голям проблем и е нормално, само че е добра идея да пратя резултата на хората
от php.

Докато чаках тестовете намерих това:
https://www.php.net/manual/en/install.unix.apache2.php?fbclid=IwAR3WxbY3fVeybYMonCFojd57Fr9JD2IdP5ZHzm9rel69QSQqJnFbvO49AhI
Навсякъде виждам PHP да е пуснато с поддръжка на my-sql не съм сигурен това нужно ли е или не, ама
нямах проблеми при build, така че залагам на не. Вероятно тук са конфизите нужни за apache-а, така
че да разпознава php файлове.

Време да си напиша първия php application. Потърсих в нета hello world php и попаднах на това, което
имаше и php info командата: https://www.php.net/manual/en/tutorial.firstpage.php . Копирах само това
от края на страницата: <?php phpinfo(); ?> и го пуснах с php командата, която build-нах и работеше.
Бях много щастлив. Остана apache-а. 

Като начало добавих info.php в htdocs до index.html-а, който се зарежда по подразбиране. После
тръгнах да добавям php модула както е показано в по-горния линк, но той се оказа добавен вече. Явно
при build-а на php. Понеже съм работил малко с httpd конфигурирането му да показва info.php фйала не
беше трудно. Това, което направих беше да взема  SetHandler application/x-httpd-php и да го сложа
под <Directory> тага за htdocs папаката с моя файл. Смених и името на файла, който се връща по
подразбиране с info.php и воала тръгна.

В този момент се усетих, че не компилирах php с libgd, което вероятно е била целта и ме хвана яд.
Намерих това: https://www.php.net/manual/en/image.installation.php и добавих флага --enable-gd и 
--with-external-gd. Проблем беше, че не намерих флаг да сменя libpng в configure. Като цяло за png
нямаше никакви флагове на моята версия на php. Реших да го оставя така пък каквото. Гугълвах и не 
намерих алтернативен флаг.

https://www.php.net/manual/en/migration74.other-changes.php тук също пише, че вече libpng флага е
махнат и че ни трябва libpng. Честно не знам какво значи това. Дали ползва системното или му е 
вградено. Тогава се усетих, че мога да използвам LDFLAGS за да го вкарам, както по-горе за една от
библиотеките. Ползвах горната схема с -L за lib файловете и -I за include за cppflags. Надявам се 
това да работи. Това ми е посления опит и генерирания html го предавам. Ами май не го подкарах в 
крайна сметка. Имах още тестове за libgd, които не работят, но не остава време. Версията явно
иска да ме прецака. Една версия назад и горните ми опити щяха да са просто ./configure команда.
Еми шанс. Иначе имам контролно утре и ще седна да погледна едно две неща за него сега и затова 
предавам по-рано, а и мисля, че другите проблеми могат да се изгладят просто трябва малко гугълване.
 
Прекарано време: 20 часа.
