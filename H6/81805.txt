Като начало реших да прегледам презентацията от лекцията. Не знаех какво сме взели миналия път,
защото имах контролно и като се включих в лекцията видях, че тя беше завършила и чух само няколко
заключителни думи. От презентацията видях, че голям част от командите, но знам в този случай не
значеше използва съм ги за жалост. Бях чувал повечето, но някакси, като не си в среда, в която ти се
налага активно да мониторираш голяма система не ти се налага често да използваш повечето от
командите. Тук може и да греша и да са свръх полезни, ама не ми се е наложило да ги използвам.

Като първа стъпка пуснах file командата над neurotoxin, да видя с какво ще работя. Видях, че това е
executable файл. При това pie executable, което май от миналото домашно научих, че значи, че кода е
position independant, т.е. мога да го пусна навсякъде на системата и да работи. Също така реших да
видя какво беше ELF, защото го бях прочел за строенето на kernel-а, ама съм забравил. Разбрах, че е
файл формат за executable файлове. Доколкото разбрах той не зависи от процесора или някое ISA.
Поради това много операционни системи го поддържат. Разгледах layout-а, че има program header, който
касае сегменти от паметта(кой сегмент от къде да се зареди и така нататък), section header, който се
дели на код(командите, като write и тн), данни(string-овете, над който се пускат командите например)
и имена на секции(като гледам има секции за текст или read only, ама не съм наясно за какво са).
Section header таблица, която ми напомня на Master boot record. Показва къде секциите започват и
носи метаданни за тях. Има и header за самия ELF файл, който предполагам е с някакви метаданни. Абе
тази графика е много готина: https://upload.wikimedia.org/wikipedia/commons/e/e4/ELF_Executable_and_Linkable_Format_diagram_by_Ange_Albertini.png

След като разгледах elf сравнително как работи, макар и да не задълбах много. Следващата стъпка беше
да пусна файла, който свалих, защото проверката е висша форма на доверие и наистина получих
segmentation fault. Да не повярва човек. Остана да разбера и защо. 

Като начало исках да получа някъкв stack trace на програмата, за да разбера къде точно се чупи и
какво води до чупенето. Като първа идея имах да пробвам gnu debugger, защото все пак ще дебъгвам
програма, да видя как работи. Преди съм го използвал, когато много се отчайвах при дебъгване на
c++(понеже използвах vim за IDE) и преживяването не ми е от любимите. Върши работа, ама е много
неудобно, ако не си виждаш кода, а екрана на лаптопа ми е малък.  Тук даже не знам на кой ред да
сложи break point, което също би ми било проблем. Не съм сигурен дали ще прекрати преди segmentation
fault-а. Вероятно ще е полезно да почета малко man page-а преди да започна с работа. Остана само да
се надявам, че програмата е написана на c или c++, за да работи идеята ми.

След прочитане на man page не видях много полезна информация. Интересно ми беше, че можеш да пуснеш
gdb на работещ процес, ама да се върнем на темата. Моментът на истината настъпи да видя дали gdb ще
сработи. За щастие бях нацелил. Пуснах с кода да се изпълни и ми излезе реда, на който програмата се
чупи. За жалост бях дотам с велики идеи и реших да си припомня малко командите на gdb. Знам, че
има help меню, но имаше бая опции в него и реших, че ми трябва нещо по просто като начало. Гугълнах
и попаднах на това: https://www.tutorialspoint.com/gnu_debugger/gdb_commands.htm . Спомнях си, че
мога да принтирам части от кода с list, но надеждата ми умря, като устнових, че трябва да му подам
source кода.

Като следващата стъпка реших да направя глупавото нещо да цъкна breakpoint на main и да правя step
ред по ред, за да видя кога се чупи. Доколкото знам step върви и изпълнява кода ред по ред и фактът,
че веднага гръмна програмата ми подскзва, че грешката е вероятно на ред 2. Понеже шестнайсеттичното
число, което симоволизира реда, на койтое гръмнала програмата е доста голямо за разлика от това,
което показва реда на main предполагам, че може да има някаква jump инструкция. Все пак реших да
видя в интернет дали има връзка между шетнайсеттичните числа, които виждам и редовете на кода и
отговорът беше не. Това просто са адреси на машината: 
https://stackoverflow.com/questions/20304074/how-to-i-see-the-line-number-of-source-code-thats-causing-a-segmentation-fault

Реших обаче, че нещо пропускам. Няма как да дебъгна нещо без да мога да видя поне някакъв код или
нещо да се ориентирам какво стана. С малко гугълване открих disassemble командата:
https://sourceware.org/gdb/current/onlinedocs/gdb/Machine-Code.html Имам чувството, че и преди съм я
чувал, но вероятно не съм я използвал и съм я забравил. Разглеждайки примерите се надявах, че мога
с disassemble да видя кода на майн, използвайки /s, и да се ориентирам къде се чупи. За целта все
пак реших да си запиша hex числото, на което има segfault: 0x00005555555552db, защото вероятно това
число ще е полезно, за да се ориентирам кога ще се счупи.

Видях асмеблера и той ме видя и се гледахме умно една минута пред да си кажа, че си нямам и на идея
какво чета. Реших да си отворя списък с регистрите на x86 ISA, за да мога поне малко да съм наясно
кои са за общо ползване и кои специализирани. Също така не всяка команда знам на x86. Миналата
година учихма само RISC архитектури, които са с по-простички команди. Като начало разгледах
уикипедия страницата: https://en.wikipedia.org/wiki/X86_assembly_language и видях, че първите
няколко реда всъщност представляват заделяна на памет върху стека и запаметяване на викащата main
функция. Това общо взето започна да ми обяснява защо толкова много асмеблер е два реда на c. Очаквах
доста редове да има, защото все пак дори най-простичкия bubble sort е гаден за писане на асмеблер
доколкото знам и се оказах прав. Регистрите в уикипедия страницата ги имаше, но нямаше подробно
описание на командите. За тази цел открих този линк: 
http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html#:~:text=The%20lea%20instruction%20places%20the,and%20placed%20into%20the%20register.

Иначе все пак кратко overview на регистрите:
AX,RAX и други: използват се за акумулиране примерно на сума при сметки.
BL, EBX и други: сочат към началото на масиви.
CL, ECX: броячи за цикли и подобни.
DX, EDX: за по-точни сметки. Extend-ват акумулиращите AX и тн.
SI, DI: source и destination индекс за работа с низове.
SP: stack pointer. Сочи върха на стека
IP: Сочи следващата инструкция
BP: сочи дъното на настоящия стек, т.е. откъде ни започва програмата.

Понеже ме домързя не на всеки ред има и други, ама има и други. Просто не мисе пишеха всички
разновидности. По спомен R регистрите бяха за 64 битови операции. E са 32 битови, X от hex май са 16
битови и H и L, които са 8 битови. Учудващо доста помня от курса по КАРХ, от което съм доволен. Като
гледам нещата бързо се сещам, макар и да не се фокусирхаме върху интелските архитектури. Разбрах, че
синтаксиса на асмеблера се нарича GAS: https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax и като
гледам кода май имам идея от къде може да идва segfault-а. Първо все пак ще кажа, че видях, че
movzbl е инструкцията, която води до грешката. С амлко помощ от тук
https://stackoverflow.com/questions/9317922/what-does-the-movzbl-instruction-do-in-ia-32-att-syntax
разбрах, че това конвертира по-малък регистър в по-голям и го zero extend-ва. movzbl = move zero
extend byte to long. Тук има и пример как работи:
https://en.wikibooks.org/wiki/X86_Assembly/Data_Transfer Иначе като гледам се вика getenv
функцията. Тя търси за някаква environment променлива, която не намира. После се опитва да и
използва, но получава NULL и това води до SEGFAULT. Това поне ми е идеята в момента. Колко съм прав
и колко си измислям е друг въпрос.  Понеже реших да помисля в друга посока различна от асмеблер се
зачудих какво друго мога да направя.  Сетих се за ELF файловете и започнах да си мисля дали има
начин да .data секцията, която видях или по-точно да достъпя паметта, където се пазят стринговете и
в случая идеята ми беше да е името на environment variable-а. В процеса открих как с info registers
да видя адресите на регистрите и тяхното съдържание. Научих се и как да слагам breakpoint-и на
дадена инструкция(както би очаквал човек. Взимаш й адреса и пишеш b <address>). Също така вече знаех
как да принтирам стойността на променлива на даден адрес с print *<address>. Тази статия за gdb ми
беше доста полезна: https://www.recurse.com/blog/7-understanding-c-by-learning-assembly . Разбрах,
че gdb не използва AT&T синтаксиса отгоре. Също така разбрах как да използвам x, за да чета паметта
на регистрите. Преждевременно разбрах, че май съм прав за getenv. В същата статия пишеше, че е
стандарт в eax/rax да се връщат резултатите от функции, но като резултат получих 0x0, което
предполагам е еквивалентно на null. Един гугъл по-късно го потвърди, както и спомена от ОС
практикум, че (void*)0 е NULL:
https://stackoverflow.com/questions/1765171/instead-of-null-should-i-write-0x0-or-0#:~:text=0x0%20is%20just%200%20written,and%20does%20the%20same%20thing.
Също така видях, че mov се присвоява от дясно на ляво, а не наопаки, както очаквах заради други ISA.
Реших да гугълна да видя кои регистри се използват за подаване на аргументи на функция и открих
това: http://6.s081.scripts.mit.edu/sp18/x86-64-architecture-guide.html . Така вече мога да прочета
регистрите преди getenv и да видя дали мога да дешифрирам думата. Тук май нацелих. Виждам, че на rdi
му се дава стойност точно преди getenv. Залагам, че това е аргумента. Остана само да видя как да го
прочета. Стойността според info registers е: 93824992239675. Това обаче не знам дали е ASCII или
нещо друго. Ако е ASCII първия конвертор в гугъл не свърши работа за жалост. Дали не е заради
endian-а? Ами и наопаки записано не стана, а и това май трябва да е от значение за адресите само
май. Тогава реших, че вместо да търся в нета може би gdb поддържа тази функционалност да прочета в
string-ов формат прословутото число. Ще ми се да кажа, че четох подробно опциите за x, защото реално
това би било логично имайки предвид, че чете паметта и видях /s опцията, която е за string, ама съм
уморен и просто го гугълнах: https://stackoverflow.com/questions/21743253/how-to-get-string-value-of-integer-in-the-eax-register
Много stackoverflow този път, ама за специфични команди мисля, че е валидно, като решение. Все пак е
добре да чета по-подробно опциите на gdb и да се стегна. Днеска реално ми е уморено, ама това не е
извинение. Все пак открих стойността на rdi и тя е TMPDIR. Сега ще сложа променлиата на това и ще
видя работи ли. И какво да видя стана :D. Излезна ми резутлат:
I am going to need you to activate the manual locks on the vault door itself.
Enter security code:
което вероятно е за бонуса. Тази част от заданието ми отне към 3-4 часа. Иначе за step командата
вероятно просто трябва да подам source code-а, за да знае коя команда на кой ред е  какво да
изпълни. В момента, като няма source код няма представа за редове и не може да индексира командите.
Затова в един от линковете се споменаваше, че не трябва да мисля в редове код, а в адреси на
команди. Пак е подобно на редове код, но все пак различно.

На другия ден разгледах малко повече асемблера за около час да видя какво става за бонуса. Знаех, че
вероятно ще има някакъв if, който проверява дали стрингът, който подам като парола е валиден.  Него
асоциирах с някое cmp и някоя jmp инструкция, която да мести instruction pointer-а на правилното
място. Потърсих командата за вход, която приема input-а ми. Намерих съответно fget. Видях, че след
него скачаме до края на асемблера и пак прескачаме обратно. Там се случва някаква аритемтика, която
не разбирам съвсем и мисля, че четем от паметта информация на адреси -0x120rbp и после правим нещо с
това и input-а ми. Това ми го подсказаха редове, като този: movzbl -0x120(%rbp,%rax,1), %eax - това имам
чувството, че има общо с квадратните скоби на intel ISA-та, но не съм на 100% убеден все още. След
аритметиката сравняваме два от регистрите(if-а, който търсех), участващи в нея и ако са равни,
стигаме до желания резултат. Ако не са, стигаме до грешка, че си губим времето. Намерих в началото
тези стрингове да се зареждат от паметта с lea(load effective address) командата и видях, макар и
твърде рано, че наистина има торта :D. Също така видях, че в началото се реферират част от адресите,
които са споменати в аритметиката по-долу преди if-а, който трябва да ме пропусне. Исках да прочета
какво имам на тях като стойности и дали информацията е смислена, но получавах грешки. Имам две
хипотези или просто на тези места слагаме адреси, а не данни или просто данните са твърде големи за
един регистър и за това са разделени във два регистъра и после се записват в паметта един след друг.
Кое от двете е още не съм сигурен. Изглеждат ми по-скоро все едно на променливи се присвояват
някакви стойности но предстои да се потвърди. Ако разбера тези стойности вярвам, че ще мога да
дешифрирам аритемтиката и да въведа правилната парола. Много съм доволен от тези си разсъждения,
защото имаше съвсем малко гугълване за какво правят командите lea и cmpb и ми отне малко време(час):
https://stackoverflow.com/questions/22801152/understand-cmpb-and-loops-in-assembly-language
Сега видях, че на горното има странния синтаксис. Трябва да разгледам линка утре значи.
Ето го и този за lea:
https://stackoverflow.com/questions/1658294/whats-the-purpose-of-the-lea-instruction
Според мен идеята цялостно я разбрах. Остана да гугълна и да изчистя някои концепции, за да дооправя
задачката, но се чувствам, че доста напреднах по нея. Дали се заблуждавам само времето ще покаже.

Ден 3. Днеска мога да вложа малко повече време в разучаването на командите за това какво точно
правят отделните команди и разшифроването на паролата. Като начало исках да видя дали има по
специално значение на стойностите, които се записват в началото в адреси като -0x120. За целта реших
да гугълна какво правеше movabs(мисля, че просто местеше константни стойности в регистри, и бях
прав) и да видя как точно се записва информацията. Два movabs се записват в съседни регистри.
Интересно ми е да разбера дали заедно не правят смисъл за разлика от по отделно. За мое щастие един
от табовете, които съм линкнал по-горе беше отворен от онзи ден:
http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html#:~:text=The%20lea%20instruction%20places%20the,and%20placed%20into%20the%20register.
Като го разгледах осъзнах, че от тук мога да извлека много повече информация отколкото бях
първоначално. Причината беше, че когато го открих бях много уморен и не се зачетох в съдържанието
толкова подробно. Тук има доста информация за регистрите, като коя част точно е AL и коя AH, защото
помня, че те бяха части от EAX. Също така има вариацията на mov от вчера, която не разбирах и
вероятно още доста полезна информация. Приемрно разбрах, че -0x120(%rbp, %rax, 1) е адреса на 
rbp + rax offset-нат с  -0x120 и от там реално четем информацията, която записваме в регистрите. Тук
не знам дали гледаме адреса на rax или стойността. Имам чувството, че може да е и двете и затова
трябва да погледна по-подробно. Нещо ми подсказва, че е адреса, ама знам ли. Нещо много полезно на
статията бяха командите, но и не само. Също така си припомних, че локалните променливи са с
отрицателен offset. Ако вземем памет с положителен offset, то тя е параметър вероятно. Calle и
caller правилата си ги спомнях сравнително, но също беше полезно да си припомня кои регистри се
възстановяват и кои не, а и цялостно целият процес на заделяне на памет и върху стека да си го
припомня как работи беше интересно. Може и да знам теорията зад него, но асемблера да го чета е една
идея по-трудно. А и голяма част от командите, които гугълвах тук са описани. Не знам защо не съм
прочел тази статия по-рано :(.

Като следваща стъпка исках да видя колко са големи числата, които в началото се записват в movabs.
Отговорът е, че имат 16 цифри и са в 16-тична бройна система,т.е са по 64 бита или 8 байта.

Това са ми белжеките какво има на отделните части от паметта:
 -0xc0(%rbp) - ""
 -0x120(%rbp) - "Uodlvqsi" - след първия mov. Като записваме само rax 
 -0x120(%rbp) - Uodlvqsii}ogu!.n - след втория mov в 0x118 - тук използвах info registers да видя
 адреса на rbp и онлайн калкулатор, да сметна адреса в паметта: 0x7fffffffde90. Иначе съм бил прав,
 че това са две думи една до друга. :D Забравих да спомена, че на горния адрес използва x /s да
 прочета данните, записани на него.
 -0x110(%rbp) - c1\177fw}6vk9S<x=rp - сметнато по горната схема
 -0x100(%rbp) - "VD\002WK\005HH_\005\nb\fNOA" - аналогично на горните.
 -0xf0(%rbp) - "\027E\022TQA\026CP\\\032UYHLP" - аналогично
 -0xe0(%rbp) - "4.:**e/)<&j2#8<o" - стига аналогично. Същото е и надолу.
 -0xd0(%rbp) - "8437t48.x?;((8,q"
 Понеже горните стрингове са последователни адреси в паметта, като ги комбинраме като капитан
 планета получаваме:
 "Uodlvqsii}ogu!.nc1\177fw}6vk9S<x=rpVD\002WK\005HH_\005\nb\fNOA\027E\022TQA\026CP\\\032UYHLP4.:**e/)<&j2#8<o8437t48.x?;((8,q"
 Време да изпробвам това за парола XD. Отговор не е :(. Еми време да разгледам другата логика

 -0xe61(%rip) - /run/user/1000 - actual - The difference between us is that I can feel pain.
 -0xe11(%rip) - BG.UTF-8
 -0xe02(%rip) - C_TELEPHONE=bg_BG.UTF-8
 -0xdbf(%rip) - =nikolay
 горните rip-ове са реално на %rbp стойностите с тези offset-и. На някакъв чист късмет са смислени и
 вероятно не са от значение. Сега осъзнах, че използвах грешен базов адрес :(. Поне знам, че идеята
 е вярна.  Установих и, че point-ера за върха на стека се променя с времето, което е логично имайки
 предвид, че заделяме памето, но това е досадно за четене на стойности. Мисля да зарежа това, защото
 това мисля, че са стринговете за prompt-а и надолу май не се иползва

 Сега осъзнах, че мога просто да напиша $rbp - 0x120 и да си спестя онлайн калкулатора :(. Много
 време замина в тази глупост. 

 Тук май има нещо гнило. Като гледам чета данни от -0x18(%rbp) и смятам с x /s $rbp - 0x18. Това
 обаче дава различен резултат от това, което mov командата записва. Едното връща TMPDIR, а другото
 ;SUUU. Напълно е възможно нещата, които съм записал до тук да са пълни небивалици :(. Възжможно е
 да се окаже, че онзи горния дълъг стринг ще се окаже просто промпта прочетен зле и ще ми стане тъпо. 
 Иначе устванових, че в 0xc0(%rbp) се записва паролата, която въведа. 

 Разбрах, че cltq се използва за sign extend-ване на 4 байта в 8 или int -> long
 https://stackoverflow.com/questions/6555094/what-does-cltq-do-in-assembly

Реших да разгледам ред по ред какво се случва преди if-а:
    movzbl -0x1(%rbp),%eax - записваме 0x0 в eax
    cltq - разширяваме до long
    movzbl -0xc0(%rbp,%rax,1),%eax - зарежда се паролата, която въведох от rbp в eax. Тук $rax е 0x0 и не участва
    movsbl %al,%edx - sign exent най-десните битове от eax регистъра в edx. С други думи заради
    little endian началото на стринга, който въведа.
    movzbl -0x1(%rbp),%eax - първия път като минем записва 0x0 в eax
    xor    %eax,%edx - eax = 0x0, т.е edx се запазва
    movzbl -0x1(%rbp),%eax - пак записваме 0x0 в eax
    cltq   - разширяваме до long 64 бита
    movzbl -0x120(%rbp,%rax,1),%eax - взимаме първите 4 бита от красивия дълъг стринг
    movsbl %al,%eax - взимаме му първата буква и я sign extend-ваме
    cmp    %eax,%edx - сравняваме и сетваме бит, който се използва за jump-ването на следващия
    ред,който не съм добавил тук.

С други думи първата буква на паролата е U. Видях после, че има jmp инструкция след това, която
инкрементира -0x1(%rbp) с единица и пак се въртят горните инструкции. Този път обаче четем втората
буква от паролата ми и я сравняваме с втората буква от дългия стринг. Тук обаче xor-а започва да
играе роля. Нашата цел е да го накараме да не прави нищо и на теория би трябвало да работи. Като
идея реших да използвам цикличността на xor. Знам, че примерно за втора буква искам o(желания
резултат) и xor-вам с 0x1(поредния номер на буквата като броим от 0) и и искам. Идеята ми беше първо
да напиша bash script, но не бях сигурен как да конвертирам стринга към hex. Видях, че мога да
напиша и gdb script, но все пак останах с баш.  Използвах и функционалността на gdb, за да
изпълнявам xor операции. Видях как от тук:
https://unix.stackexchange.com/questions/292344/how-to-calculate-hexadecimal-xor-from-shell
calc_gdb() { gdb -q -ex "print/c $*" -ex q;} Този скрипт влиза в gdb в quiet режим(не излиза 
copyrigth промпта) изпълнява print /c на подадаените аргументи и излиза от програмата.
После с x /96x $rbp -0x120 взех всичките символи от gdb в hex. Копирах ги в баш скрипта и ги
обходих, като с един брояч следях до кой символ съм стигнал.  Конвертирах числото в hex с printf %x
и изпълних calc_gdb() на поредния номер и на симовла от дългия стринг в hex. Така на 300 реда ми
излезе резултатът, ама беше достатъчно, за да мога да го прочета и да получа за парола:

Unfortunately, as much as I'd love to now, I can't get the neurotoxin into your head any faster.

И най-накрая получих тортата, като вече е заслужена.


bash скрипта, че не знам колко добре се разбира обяснението ми без да се гледа кода:
#!/bin/bash    
counter=0                                             
                                       
calc_gdb() {                           
    gdb -q -ex "print/c $*" -ex q      
}                                      
                                     
for i in "0x55" "0x6f"  "0x64"  "0x6c"  "0x76"  "0x71"  "0x73" \    
"0x69" "0x69"   "0x7d"  "0x6f"  "0x67"  "0x75"  "0x21"  "0x2e"  "0x6e" \    
"0x63"  "0x31"  "0x7f"  "0x66"  "0x77"  "0x7d"  "0x36"  "0x76" \    
"0x6b"  "0x39"  "0x53"  "0x3c"  "0x78"  "0x3d"  "0x72"  "0x70" \            
"0x56"  "0x44"  "0x02"  "0x57"  "0x4b"  "0x05"  "0x48"  "0x48" \    
"0x5f"  "0x05"  "0x0a"  "0x62"  "0x0c"  "0x4e"  "0x4f"  "0x41" \    
"0x17"  "0x45"  "0x12"  "0x54"  "0x51"  "0x41"  "0x16"  "0x43" \    
"0x50"  "0x5c"  "0x1a"  "0x55"  "0x59"  "0x48"  "0x4c"  "0x50" \    
"0x34"  "0x2e"  "0x3a"  "0x2a"  "0x2a"  "0x65"  "0x2f"  "0x29" \    
"0x3c"  "0x26"  "0x6a"  "0x32"  "0x23"  "0x38"  "0x3c"  "0x6f" \    
"0x38"  "0x34"  "0x33"  "0x37"  "0x74"  "0x34"  "0x38"  "0x2e" \    
"0x78"  "0x3f"  "0x3b"  "0x28"  "0x28"  "0x38"  "0x2c"  "0x71"      
do                                                                  
    hexCounter=$(printf "0x%x" $counter)                           
    calc_gdb ${i} ^ ${hexCounter}           
    let "counter++"                  
done

Може да има и по-лесен начин горното да стане с някакъв цикъл в gdb, ама не го открих.

Проблемът защо понякога четях различен резултат с x /s $register + offset, но mov записваше различно
нещо в регистъра не успях да разбера защо е.

Време за работа: 10 часа. 3 за част 1 и 7 за част 2.
