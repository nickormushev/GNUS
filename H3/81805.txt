Като начало реших да се подсигуря, че internal network е това, което си мисля, а именно мрежа, в
която могат да участват само виртуалните машини на virtualbox. Погледнах на този линк:
https://www.virtualbox.org/manual/ch06.html#network_internal и установих, че хипотезата ми е
правилна. Идеята ми за начало преди да съм чел каквото и да е друго освен горното е да конфигурирам
banshee, като dhcp сървър, като използвам dhcpd демона за вътрешната(internal) мрежа на virtualbox.
Ще го конфигурирам с употребата на PXE, така че да boot-ва от него aswang по мрежата. Също така
конфигурирах virtualbox спрямо инструкциите и забелязах, че макар че aswang има hard disk не се
стига до login екран и не мога да влезна със student, кото не ми е напълно ясно защо е, имайки
предвид, че hard disk-а е все още в boot order-а. Реших да го пусна пак и просто да съм по-търпелив
и login екрана тръгна. Доколкото виждам прави dhcp discover много дълго време в опит да си намери
мрежова конфигурация, ама няма кой да му отговори поне докато не конфигурирам bashee. 

Като начало използвах ip a и ip r, да се ориентирам кои са interface-ите на машините и кой е
interface-а/коя е мрежата заделена от virtualbox за internal network. Видях 3 ethernet интефейса
eth0, eth1 и eth2. eth2 беше долу и нищо не му беше конфигурирано и предположих, че той е
интерфесейса за вътрешната мрежа.  Реших като начало да опитам да конфигурирам двете устройства с
private address-и 172.16.0.0/24 мрежата и да видя дали ще се говорят от там. Едната мрежа беше и с
default gateway, което предполагам е мрежата, в която се намира компютъра ми, защото е получил тези
данни от някакъв dhcp сървър или рутер, който играе ролята на dhcp сървър. На втората машина има
само един мрежови интерфейс, който съвпада с internal network адаптера и той няма конфигурирани
адреси. Използвах ip addr add, да конфигурирам двете машини с адреси 172.16.0.1/24 и 172.16.0.2/24
като адреси. С ping си потвърдих, че между устройствата има комуникация. Реших да видя тези настройки
пазят ли се(по спомен не се, ама все пак да се подсигуря) при рестарт на машината. Както очаквах конфигурациите
бяха затрити, което е ок, защото и без това на aswang искаме interface-а да се конфигурира с dhcp, но за 
banshee бих искал ip-то да е статично, за да е консистентно и защото няма как да си задели сам ip address.
Тук е проблема с яйцето и кокошката. За да си задели ip address машината трябва да има ip address, с който
да отговори на DHCP request пакета. Затова трябва да е статичен. Потърсих в интернет малко и намерих къде са
файловете, които ми трябват, а именно под /etc/network/interface и /etc/network/interfaces.d Реших преди да 
променям файла да прочета man interface(5), да си припомня синтаксиса. 
От тук намерих файла.
https://serverfault.com/questions/847851/ip-address-changed-only-after-reboot

Този файл обаче май е за ifconfig и командите от оригиналния iproute пакет.
Понеже аз мисля да използвам iproute2 реших малко повече да се поразровя преди
да правя промени.
Намерих този сайт с доста информация за iproute2:
http://www.policyrouting.com/iproute2.doc.html
Изглежда доста полезен.

Потърсих дали /etc/network/interfaces използва оргиналния iproute пакет. В stackoverflow намерих отговор, че
този файл се използва и в двата случая, а отдолу операционната система използва едно от двете.
https://superuser.com/questions/1206719/which-utility-uses-etc-network-interfaces
Това ме мотивира да прочета малко по-подробно man страницата, защото проверката е висша форма на доверие :D.

В man page-а намерих как статично да си конфигурирам интерфейс, ама дали информацията от stack overflow е вярна
не открих. Намерих друг проблем, че мрежовите интерфейси си сменят имената при reboot, така че не е ясно дали няма
конфиуграцията да се прецак при рестарт на машината, ако примерно вкараме флашка.

Най-накрая намерих потвърждение за данните от stackoverflow, че /etc/network/interfaces използва iproute2 вече
в wikipedia страницата на debian тук https://wiki.debian.org/NetworkConfiguration#iproute2_method

В interfaces man page-а бяха дадени пътища към файлове с примерни конфигурации и прегледах конкретно 
/usr/share/doc/ifupdown/examples/network-interfaces там беше показано как да направя mapping към 
mac address на мрежови интерфейс, така че да е консистентно и да не се губи информацията при рестарт
и реших да пробвам тази конфигурация.

Прекарах доста време да си играя с mapping и да се опитвам да го подкарам. За жалост мисля, че е добре
да продължа напред със задачата и ако остане време да го помисля пак. Иначе разбрах общата идея. Подаваме
script той получава за първи аргумент това, на което правим mapping(в нашия случай eth0 eth1 и eth2).
После този script използва read и получава като параметри редовете с map <mac address> <interface name>
и match-ва по интерфейс. Съответно, ако mac адреса съвпадне с този на eth0 връща името, което сме му сложили
и така те се мапват и това използва interfaces файла да чете. 

Реших все пак да сложа неработещата конфигурация тук, така че да може после да попитам къде бъркам, ако не го измисля.
interfaces file:

auto eth0 eth1 eth2
mapping eth0 eth1 eth2
	script /root/get-mac-address.sh
	map 08:00:27:f0:91:bb internal
	map 08:00:27:3a:f4:34 nat
	map 08:00:27:d6:17:fa host
iface internal inet static
	address 172.16.0.1
	netmask 255.255.255.0
iface nat inet dhcp
iface host inet dhcp

get-mac-addresses.sh: - този файл го намерих на операционната система от приметните настройки под example в документацията.
Не съм го писал аз но разбрах идеята му, която описах по-горе. Взима mac адрес и връща името, което сме му задали.
#!/bin/sh

set -e

export LANG=C

iface="$1"
mac=$(/sbin/ifconfig "$iface" | sed -n -e '/^.*HWaddr \([:[:xdigit:]\-]*\).*/{s//\1/;y/ABCDEF/abcdef/;p;q;}')
which=""

while read testmac scheme; do
	if [ "$which" ]; 
    then 
		continue;
    fi
	if [ "$mac" = "$(echo "$testmac" | sed -e 'y/ABCDEF/abcdef/')" ]; 
    then 
        which="$scheme"; 
    fi
done

if [ "$which" ]; then echo $which; exit 0; fi
exit 1

Така наконфигурирах interface-а с горните настрйки само, че махнах mapping-ите и използвах eth2
вместо internal, а на другите места eth1 и eth0 за автоматична конфигурация с dhcp. Реших вече да
минавам към настройването на dhcp сървъра и проверих дали dhcpd демона е инсталиран на banshee. За
моя жалост не беше, което значи, че трябва да си го инсталирам. Направих apt update да дръпна
информация от repo-тата на debia и инсталирах пакета isc-dhcp-server за dhcpd. След инсталацията
седнах да чета man page-а. В него бяха обяснени концепциите на dhcp, как работи, че му се
конфигурира pool от адреси, които раздава и които се пазят в leases файл, така че да няма
конфликти(да не раздаде един и същи адрес два пъти) и така нататък. Там получих информация да
прегледам dhcpd.conf man страницата, която описва как да конфигурирам нашия сървър да прави своята
магия.  auto eth0 eth1 eth2 - пуска интерфейсите.

Като начало реших да направя базова конфигурация, така че aswang да получи ip address динамично от
banshee. Казах със subnet, че dhcpd сървъра трябва да раздава адреси в 172.16.0.0/24, което е
internal интерфейса. После дадох range от адреси 172.16.0.2 - 172.16.0.254 - този range започва от
172.16.0.2, защото 172.16.0.1 е статично конфигуриран на banshee на интефейса и завършва на 254
заради broadcast адреса на мрежата, който е 172.16.0.255. Така като вече знам, че dhcp сървъра ми
работи продължаваме напред с още четене на man page, така че да разбера как да конфигурирам pxe. Не
знам дали само с man страницата ще стане или ще трябва малко гугълване също, ама ще видим.

Зачетох се в man page-а ама стана късно и се поуморих. Видях полезни опции като filename-името на
файла, от който ще boot-не нашата машина, next-server - hostname-а на сървъра, от който клиента ще
получи файла за boot-ване. Засега реших утре да погледна повече. 

На другия ден(малко по-свеж) реших да прегледам малко повече за PXE в интернет. dhcpd.conf беше
доста полезен и крие доста информация има, ама нищо не обяснява точно как работи PXE поне от това,
което видях(разбира се може да съм пропуснал нещо), а целта на задачата вероятн ое да boot-на с PXE
:D.

Като начало прочетох wikipedia страницата:
https://en.wikipedia.org/wiki/Preboot_Execution_Environment Разбрах, че вероятно ще ми трябва tftp
сървър, на който да сложа файловете на операционната система, към който моя DHCP сървър ще насочи
aswang хипотетично, използвайки командите next-server и filename. Така той ще свали от него
файловете и ще ги зареди в RAM. После ще получи допълнителни инструкции по HTTP примерно, който
казват как да си инсталира операционната система. На aswang доколкото виждам не трябва да правя
нищо, защото на него му е нужен единствено NIC, който поддържа PXE. Това вече го имаме от virtualbox
и не се налага да го настрайваме повече.

След това намерих страницата на сайта на debian, на която е описано как да си настроя PXE:
https://wiki.debian.org/PXEBootInstall Започнах да ходя по описаните стъпки. Вече бях настроил dhcpd
сървъра си и използвах препоръчания пакет(tftpd-hpa), да инсталирам tftp сървър на banshee. След
това инсталирах tftp-hpa на локалната си машина и се вързах успешно към сървъра. Реших обаче преди
да продължа да прочета малко командите за настройка на tftpd и тези за сваляне на файлове от сървъра
от съответните man страници.  Не ми беше ясно как да кажа, че даден файл може да се свали от tftp
сървъра. Да сваля файл от него бързо разбрах, че става с get командата, но все пак мисля, че има
смисъл малко да попрочета.

След прочитането на man страниците видях някакви опции като remapping и подбони и че мога да слагам
файлове на tftp сървъра с put командата.  Това може да е полезно, да прехвърля операционната система
на виртуалката вместо да използвам scp. Другото, което забелязах е, че съм сляп и в линка за
PXEBootInstall на debian са показани стандартните настройки на tftpd сървъра, в който е включена и
директорията, в която са фйаловете, който са достъпни за навън, която по подразбиране е /srv/tftp.
Прочетох и какво прави стандартния флаг --secure, макар че все още не мисля, че го разбирам.
Схванах, че се променя root директория при стартиране и тя ти дава възможност да не я пращаш като 
част от трансфер??? Не разбирам защо ни е тази root директория при трансфер и дали това е root
директорията на tftp сървъра(вероятно да, защото иначе би било доста странно). Създадох и 
файл на сървъра, като го свалих на моят машина, да тествам всичко дали работ. Сложих файла в
подпапка нарчоно да видя дали пътищата работят стандартно като под линукс като взимаме за root
/srv/tftp. За мое щастие хипотезата ми се оказа не само логична, но и правилна :D. Тези неща поне
не ги видях добре описани в man страницата как работят.

Като следваща стъпка дръпанх network image-а от сайта на debian и го сложих на tftp сървъра с put.
Тук може би ставам леко, една идея, мънинко, твърде подробен, като се има предвид, че в линка са
описани тези неща. Наложи ми се да сложа --create опцията, да мога да създавам файлове на сървъра
и за кратко направих chmod 777 на /srv/tftp, да се прехвръли файла, защото нямах write права.

Като вече tftp сървъра ми е настроен остана да донастроя dhcp-то с next-server и filename. Още
леко ми е неясна примерната настройката с group и option architecture-type на страницата на debian.
Не знам каква е разликата между pxelinux.0 и debian/installer/amd64/bootnext64.efi. Този architeture
type също не съм сигурен за какво се отнася. Намерих rfc5970 за него, ама това не помогна много
https://tools.ietf.org/html/rfc5970#section-3.3. То ме заведе към rfc4578: https://tools.ietf.org/html/rfc4578#section-2.1
и тук видях, че 7 е тип за EFI BC, което разбрах, че стои за EFI Byte Code, на което май се пишат
драйвери за UEFI. И в този момент сцепих и се усетих, че bootnext64.efi файла вероятно е за UEFI
устройства, а pxelinux.0 файла е в случай, че се използва BIOS.

Сложих настройките за filename "pxelinux.0"; и next-server <ip-то на banshee> и рестартирах aswang.
След това бях посрещнат от BIOS инсталация на debian. С други думи успешно заредих инсталацията на 
операционната система.

Понеже исках да реша и бонуса реших да видя как мога да дам конфигурации за инсталациата
операционната ситстема без да се налага ръчно аз да инсталирам и намерих този линк:
https://www.debian.org/releases/stable/amd64/ch04s06.en.html
Има два варианта, които са описани с използване на някакъв софтуер наречен fai за масово инсталиране
на debian на много машини или просто да му кажа откъде да зареди файл, който описва какви настройки
трябва да има. Реших да опитам втория метод, защото ми изглеждаше по-близо до целите на задачката,
нищо че в реална среда може би fai би било по-доброто решние за лесна администрация.

Следвайки подлинковете на горния разбрах как да настроя dhcpd, така че като се праща заявка
за preseed file да връща информация за preseed.cfg. Намерих откъде да взема примерен такъв
файл за debian buster, на който мога да му променяма настройките както си искам. Този вариант
се препоръчва от дебиан за начинаещи. Другия вариант е да инсталирам операционната система веднъж
и да използвам файл генериран от нея, но в него има и допълнителни редове, които са ненужни и могат
да доведат до проблеми май. Може и да са конфиденциални за фирмата. Втората опция се прави с 
debconf-get-selections --installer командата, от която се генерира файл за preseed.
От тук взех файла и една страница по-рано се(на дъното има стрелка на ляво) са описани опциите.
https://www.debian.org/releases/stable/amd64/apbs04.en.html

Успях да пусна автоматична инсталация като отворих aswang и натиснах escape и зададох preceed файла
на tftp сървъра си с auto url=<host>/preseed.cfg. Продължавам да чета може ли това да стане по
подразбиране като стартираме машината, ама поне към момента не виждам как, а и пак съм уморен. Видях
на няколко места, че може в initramdisk-а да се сложи път към този файл. Също така, за да работи
тази конфигурация на 100% видях, че трябва да имам достъп до интернет мрежата, така че да може да се
свалят съответните debian пакети. Може това да е до изображението и да има такова, което не се
нуждае от връзка. Понеже нашите машини са изолирани и по-точно aswang няма достъп до интернет може
да се наложи да направя banshee да е и рутер, като му настроя default gateway и мисля, че имаше флаг
някъде из файловенте на линукс, който трябваше да сложа, да мога да го направя на рутер. Това не
знам колко е част от задачката обаче и честно казано мисля, че знам как ще стане и ще е повече
загуба на време отколкото нещо интересно поне за мен. Зависи колко време остане може да го довърша.
Все пак още ще почета дали има начин да не се налага да използвам auto url, който е по-прост.

Ето още един линк за preseed, който ме вдъхнови за auto url: 
https://debian-administration.org/article/708/Automating_the_Debian_installer_with_PXE_and_preseeding

Видях, че използваме iPXE при boot. И реших да видя какво е различното на iPXE и PXE. Разбрах, че
iPXE е open source имплементация на PXE. Понже исках auto url автоматично а се зарежда и да не се
налага да го въвежда при boot потърсих в гугъл и намерих
https://wiki.syslinux.org/wiki/index.php?title=PXELINUX#Configuration.  В този ми осъзнах, че ние
използваме точно pxelinux, което си идва с конфигурация и ми се създаде очакването, че трябва или да
създам друг pxelinux.0 файл или да използвам pxelinux.cfg/default файла(bootloader конфигурацията на
pxelinux, но засега не откривам нищо полезно. Горния линк ме доведе до този
https://wiki.syslinux.org/wiki/index.php?title=Config В него бяха описани командите и синтаксиса за
pxelinux.cfg файла. Реших да създам Label, който да направя Default и в него да сложа Append опция
за kernel boot параметрите auto url=tftp://172.16.0.1/preseed.cfg.  За да работи този файл после май
ще се наложи да добавя опцията option pxelinux.configfile code 209 = text; на DHCP сървъра ми и на
теория това би трябвало да сработи. 

В крайна сметка не се наложи опцията за dhcp сървъра и го добутах до положение, в което стартираше
инсталацията, но preseed.cfg файла не се зареждаше с тези настройки:

DEFAULT preseed

LABEL preseed
  KERNEL /debian-installer/amd64/linux
  INITRD /debian-installer/amd64/initrd.gz
  APPEND auto url=tftp://172.16.0.1/preseed.cfg

Успях да го оправя и вече на 100% автоматично се инсталира aswang като просто смених реда с APPEND на 
APPEND auto=true url=tftp://172.16.0.1/preseed.cfg

Помогна ми този човек точно с моя проблем:
https://askubuntu.com/questions/1125792/how-do-i-set-up-pxe-boot-to-use-preseed
Установих от там, че има опция само url, която всъщност ми трябва и auto=true, което
казва, че инсталацията трябва да е автоматична. Това мисля, че го имаше в някой от горните
линкове за debian, но ето го пак.
https://www.debian.org/releases/buster/amd64/apbs02.en.html#preseed-loading
Май има някакъв начин и с DHCP на същата страница, ама нямам вече време да го мисля, така че 
продължавам напред.

Сега най-накрая ще започнем да разглеждаме live image как да boot-нем.
За тази част ми трябваше live image за netboot. За моя жалост такъв нямаше на сайта на дебиан или
поне аз не видях. Затова ми се налага аз да build-на един с debian live-build:
https://manpages.debian.org/testing/live-build/live-build.7.en.html

След малко гугълване открих подробна доку,ентация на това как да си направя live image и имеше
секция точно за netboot. Все пак попрочетох малко преди да скоча директно на тази секция, защото
предположих, че ще съм объркам иначе, а и в секцията за нетърпеливите го препоръчаха(остава ми малко
време, така че няма да го хъбя).

Като начало прочетох тази страница:
https://live-team.pages.debian.net/live-manual/html/live-manual/examples.en.html#examples Разбрах,
че с lb config мога да генерирам файловата струкутра с конфигураците за строене на приложение. Под
config/package-lists мога да добавя списъци с пакети, които искам да се инсталират при build на
image-а. Има също така списъци от пакети със стандартни приложения, която мога да добавя при
инсталация например '! Packages Priority standard', който съдържа пакетите със стандартен приоритет.
С различни флагове мога да определя архитектура и други подобни на image-а, които настройки мога да
ги пазя в файл auto/config. Преди да продължа направих бърз lb config и lb build за генериране на 
стандартен image, да видя, че всичко работи.

Като следваща стъпка прочетох тази страница, която имаше описание как се прави netboot, ама реших
да не скипвам директно към важната част, да не пропусна нещо и да съм объркна после. И този build
дори на празен image, като гледам си отнема време. После като го чакам ще е тежко положението XD.

Първия image се провали да се създаде, защото нямаше място на машината. Това леко ме притеснява,
защото сега се опитвам да build-на netboot image, но не знам дали той е по-лек и дали мястото няма
да е пак малко. Просто увеличих мястото на виртуалната машина през vbox. Бързо разбрах, че това е
виртуална, а не реална памет. Затова добавих друг hard disk сложих му файлова система и го монтирах.

Тогава осъзнах, че вероятно се иска да направим минимален image и за целта се сетих, че имаше пример
за това как да напрвим 128мб image за флашка. Реших да не слагам препоръчаните от apt пакети, като 
начало. Причината за това беше, че в на сайта пишеше, че пакетите, които ще се изтрият не са жизнено
важни, а просто стандартни пакети, който бихме очаквали да има по подразбиране. Тези пакети би
трябвало да можем спокойно да си ги инсталираме.

Също стандартния image се build-ваше 300 години и можех да го чакам и първоначално очаквах, че му
трябва само малко място отгоре, но като надвиши даден размер осъзнах, че по подразбиране image-а,
който се build-ва не е свръх голям. Командата, която в крайна сметка използвах за успешен build беше
тази, която ме остави с 0.1гб сввободно място XD:
lb config --apt-indices false --apt-recommends false --debootstrap-options \
"--variant=minbase" --firmware-chroot false --memtest none -b netboot --net-root-path "/srv/debian-live" --net-root-server "172.16.0.1"

Според документацията --apt-indices единствено изисква apt-update при стартиране, да мога да използва
apt командата. Не добавя индекси за apt, които съдържат данни за добавенит от apt програми.
--apt-recommends са препоръчаните файлове, който аргументирах по-горе 
--debootstrap... е флаг за създаване на минимална система. Другите файлове са за net-boot-а.
/srv/debian-live е мястото на image-а, а --net-root-server е ip-то на aswang.

Build-нах 300 image-а и нищо не се получаваше :(
Реших да потърся в нета за конфигурационнит опции и да чета, а не да правя brute force атаки. Та
намерих това https://manpages.debian.org/stretch/live-build/lb_config.1.en.html и започнах ред по
ред да чета. Тук разбрах, че можех да добавя preseed файла към изображение, което аз съм build-нал
за netinstall не за netboot, така че явно идеята, че мога свой собствен pxelinux да си build-на също
е била валидна.

lb config --apt-indices false --apt-recommends false --debootstrap-options "--variant=minbase" \
--firmware-chroot false --memtest none -b netboot --net-root-path "/srv/debian-live" \
--net-root-server "172.16.0.1" --debian-installer-gui false --cache false --debian-installer netboot

След прочитането на man page-а от горе до долу стигнах до горната конфигурация. Спрях кеширането,
което беше ключово. Нямах достатъчно място, да пазя кеш и това спести доста памет. Опциите за
memtest прочетох, че пестят място в страницата, която показва как да направим 128мб изображение.
Проверих каквое memtest86 след четенето на man page-а и видях, че тества дали ram паметта е в ред.
В реална среда може да е добра идея да го оставя в случай на повреда да знам, но в края на деян един
компютър/сървър да се счупи не е края на света. firmware-chroot false не включва автоматично
firmware package-и в image-а. Тях може в последствие да си ги добавиш по-късно. Другите опции ги
обясних по-рано. Като най-накрая успях да създам изображени общо взето сложих файловете в
съответните им директории. ftpboot файловете в ftp директорията, а debian-live в /srv/debian-live.
Тази директория я export-ирах с nfs. И пуснах aswang без да пипам друго и той като по чудо тръгна и
се видя image-а. Остана само да цъкна live опцията. За жалост почти всичко се зареди, но ми излезна
това: /bin/sh: can’t access tty; job control turned off. Не знам дали аз нещо съм объркал/липсва
пакет или нещо друго. Сега ще дебъгвам, но скоро ще предам дори да е незавършено. Хипотезата ми за
проблема е, че спрях инсталирането на някои firmware пакети с един от флаговете. Излиза ми, че не
открива и файловата система, така че може да е проблем и с nfs-а, но вече нямам много идеи, а
остават 30 минути до крайния срок за предаване. По-рано много бързах и в крайна сметка изгубих много 
време без да мисля, а повече да му казвам да тръгне и то да не ме слуша XD. Иначе ще кача този файл 
засега и ако в следващите 30 минути измисля нещо, ще го подменя. Ако не, много тъжно.

Попрочетох малко за nfs и как се конфигурира тук:
https://www.tecmint.com/how-to-setup-nfs-server-in-linux/

направих /etc/init.d/nfs-kernel-server restart и nfs тръгна. Нещо беше се прецакал.
Не знам дали това оправя проблемите, защото си изтрих image-а като по погрешка. Пробвах от моята машина
да се вържа към nfs-а и не можах. Сега успях и затова знам, че е бил прецакан.

Време 19 часа.
