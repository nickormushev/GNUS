Тази седмица започнах със заданието(четвъртък). Имах доста друга работа и не знам дали ще ми стигне
времето да разгедам всичко подробно, ама най-накрая е време да започна. 

Като начало реших да видя какво е backport. Затова гугълнах и попаднах на това: 
https://backports.debian.org/Instructions/
Доколкото разбрах това са repository-та съдържащи пакети, които са в testing, но са прекомпилирани,
така че да работят на стабилни дистрибуции. Има и sloppy дистрибуции, които може да съдържат и
пакети директно от testing, докато другите май не могат. Съответно моята задача е да добавя debian stretch
backport repository на машината, както е описано горе и да инсталирам XMPP пакета. Бих заложил, че трябва
и още нещо да направя, защото усещам, че пакета няма толкова лесно да се инсталира. 

Преди да продължа прочетох какво е XMPP в уикипедия: https://en.wikipedia.org/wiki/XMPP 
Съответно разбрах, че е проткол за обмяна на съобщения(instant messaging) и не само. Може да се
използва за файлови трансфери, игри, IoT, видео и други. XMPP е отворен стандарт за разлика от други
подобни протоколи, т. е. може всеки който си поиска да имплементира service, работещ с този протокол
и той да работи с всички всякакви сървъри, които го имплементират. Протоколът е децентрализиран. Той
работи с клиент сървър модел. Всеки, човек може да си вдигне сървър, такъв че през него да се
разменят съобщения. В AOL например това не е възможно. Там има централен сървър през, който трябва
да минат всички съобщения, а с XMPP няма такова нещо. Разбрах, че всеки потребител има JID, който се
състои от две части username и domain във формата username@domain. Така, за да пратищ съобщение до
някого го пращаш на username@domain. Може един потребител да има много машини и да пратиш
съобщението на всяка една от тях по отделно. Приемрно на мобилния му номер username@domain/mobile.
Всяка машина има различен приоритет и по подразбиране съобщението се праща на машината с най-висок
приоритет. Username-а не е задължителен @domain се използва за конфигуриране на jabber сървъра на
този domain. Нещо готино за XMPP е, че поддържа работа с други протоколи, като AOL и SMTP. Трябва
само да му дадеш достъп и можеш да си говориш с някой, който ползва AOL или по реалистично да пишеш
на някого мейл през jabber. Това работи сървър side и използва някакви gateway-ове. Абе цялостно е
готина идеята да е централно място, през което имаш достъп до всички чат платформи + поща. Прочетох,
че XMPP може да се използва и като MOM и ми се наложи да прочета какво е това:
https://en.wikipedia.org/wiki/Message-oriented_middleware
Разбрах, че се използва за обмяна на съобщения между различни service-и с цел да се абстрахираме от
хардуера, на който работят. Също така може да работим на различни мрежови платформи и пак да си
обменяаме съобщения.

Ама стига толкова за XMPP. Време да продължаваме с работа по задачата. Като цяло разбрах, че трябва
в sources.list да добавя stretch-backports с deb командата. Проблем обаче е, че не съм сигурен дали
repository-то трябва да е някое специално. Гугълвах, но не намерих нещо, което да подсказва това.
После реших да видя дали sources.list по случайност няма man page и за мое щастие имаше. Прегледах
го и видях, че има секция suite, в която трябва да си напиша, че искам stretch-backports, за да
свалям съответните пакети. Разбрах, че най-предпочитания source е първия в sources.list. Разбрах, че
файлът не позволява да пиша една команда на много редове(one line format). Видях, че мога да
инсталирам пакето по ssh, от file, от ftp сървър, по http, от cdrom и подобни. Имаше и бая опции за
доверие към repository-то. Може да се добави key файл с fingerprints на различните repository-та, на
които имаме доверие. Може да кажем, че едно репо е супер сигурно и винаги ще му се доверяваме. Може
да сваляме само пакети на български или само за amd архитекура и още много. Разбрах и, че suite е нещо
подобно на директория в repo-то. Казваме да се взимат от там пакетите. Това ми изглежда важно поне
на пръв поглед, за да избера backports suite-а. Има и три други опции за main, contrib и non-free.
От тук: https://wiki.debian.org/SourcesList#:~:text=contrib%20packages%20contain%20DFSG%2Dcompliant,not%20comply%20with%20the%20DFSG.
видях, че main са главните пакети на debian, които са open source и безплатни. Contrib са безплатни
пакети, но имат dependency-та, които не са open source. non-free са пакети, които не са open-source
и са безплатни. Ние на машините си имаме само open-source пакети, защото всички са main. Като
заключение трябва да добавим този ред към sources.list:
deb http://ftp.debian.org/debian/ stretch-backports main 
Инсталирах и curl пакета използвайки backports, за да видя дали работи. Първоначално се провали, ама
после се усетих, че не съм пуснал apt update и след това стана.

Просветление!!! Сега след двайстия прочит разбрах, че не съм разбра втората час на условието.
Мислех, че идеята, след като добавя stretch-backport, от него да взема jabber2. Всъщнсот трябва да
взема версията на пакета за buster и сам да си направя backport на него. В момента си нямам и на
идея как ще трябва да направя backport, ама за начало ще дръпна source файловете от този линк:
https://packages.debian.org/buster/jabberd2 с wget. Пакета е свален и разархивиран успешно, но съм
до там. Ще му поразгледам README.md-то набързо, но вероятно ще се наложи да гугълна. Видях
dependecy-тата за пакета кои са. Вероятно ще ми се наложи да ги инсталирам по-късно, но ще изчакам
да видя дали е наложително. Другата информация беше стандартното ./configure make make install.
Затова гугълнах и намерих този линк, който май е просто съкратен вариянт на по-подробно обяснение на
страницата на debian: https://www.ocf.berkeley.edu/docs/staff/procedures/backporting-packages/
Разбрах каква е идеята горе долу, но ми се стори по-добре като че ли да прочета линка, който са
оставили към по-подробното описание преди да правя каквото и да било:
https://wiki.debian.org/SimpleBackportCreation Тук бях обеснени два вариант да направя backport един
по-лесен и един, който ще ми даде backport, който мога да пусна дори в официалното backports repo.
Като начало реших да видя по-простото. После, ако остане време ще видя и другото и в зависимост от
това колко е трудно би било гот да пробвам по по-сложния начин. Прочитайки крайния вариант не видях
да е свръх подробен и да ми е много ясно какво правя. Имам чувството, че трябва още да почета.
Разбрах едно нещо обаче и това е, че има разлика между deb-src и deb в sources.list. Мислех си, че
са еднакви, ама едното ми дава да свалям и source пакети. Реших да добавя buster repo-то временно и
да сваля с apt source пакетите, за да видя как става, а и реших, че може да съдържат някакви
допълнители данни. За мое щастие се свалиха и допълнително файлове. После изтрих buster repo-то, за
да не сваля някой друг пакет по грешка. И за мое щастие бях прав. mk-build-deps от линка за
инсталиране на прости backport-и сработи. Стори ми се като по-лесен начин да инсталирам
dependency-тата на пакета и да пробвам нещо ново без да ми се налага да един по един да инсталирам
пакетите. Разбрах и че има разлика между apt source и това да сваля source file-овете, защото преди
това не сработи mk-build-deps и каза, че няма dependency-та, които вероятно са в някой dependency
файл записани. Дап има файл с build dependency-тата на пакета: jabberd2-build-deps_2.7.0-1_all.deb
Като направих dch --bpo ми излезе прозорец подобен на git log, показващ различните build версии на
пакета с промените по тях, като най-отгоре е rebuild for stretch-backports, което е моята промяна.
Това е доста готино. Не знаех, че има нещо подобно. Като цяло установих, че нещо съм пропуснал. Не
съм прочел, че dependency-тата не са се инсталирали правилно и следващите стъпки се провалят заради
това. Надявах се да мога да инсталирам софтуера по по-лесния начин и после спокойно да си допрочета
каквото не съм разбрал, ама като гледам няма как да стане. Прочетох какво е dch и това е програма,
която добавя коментари, към deabian changelog-а на source пакети(както по-горе ми напомни на git
log). --bpo флага е точно за моя use case, а именно инкрементиране на changelog номера, така че да
създам stretch-backport. Описано е как мога да създавам changelog-ове по различни начини и да
генерирам такива подобни на --bpo има changelog-ове за QA, rebuild, security etc. Открих, че dget е
алтернатива на apt source и общо взето прави същото. Като следващи стъпки май ще ми се наложи да
инсталирам sbuild, което е описано тук как става: https://wiki.debian.org/sbuild. Сега обаче съм
уморен и утре трябва да ставам рано, т че ще се моля петък да ми стигне времето за всичко. Имам лошо
усещане обаче, ама ще го игнорирам засега. Разгелдах man page-а на mk build deps преди това, но там
нямаше нещо полезно. Потвърди ми, че името му е добре измислено и че --remove трие файловете
използвани при инсталация след края на инсталацията. Другото обаче ще прегледам утре.

На другия ден прегледах какво е sbuild. Установих, че е система, която build-ва пакети в изолирана
среда. То използва sbuild-chroot, което от своя страна използва debootstrap и създава чиста
инсталация на debian в chroot среда. После sbuild дърпа dependency-тата нужни за build-ването на
даден пакет и го build-ва. Съответно може да подам инструкции, така че да се build-нат backport
пакети или да кажа до какви repository-та има достъп sbuild в chroot средата. На тази страницата 
https://wiki.debian.org/BuildingFormalBackports#Building_your_backported_package имаше линк как с
sbuild-chroot да дам възможност да използва backports репота: 
https://manpages.debian.org/unstable/sbuild/sbuild-createchroot.8.en.html#EXAMPLES
Сетих се какъв вероятно е бил проблемът на първоначалния ми подход. Доколкото виждаме се търсят
пакети, които са по-нови версии. Съответно аз нямам добавено buster repository-и, за да се дръпнат
правилно dependency-тата с mk-build-deps и съответно то се проваля. Като добавих buster repo-то
изскочиха 300 пакета за обновяване на пакети като run-нах mk-build-deps. Бях достатъчно разумен да
погледна условието и да видя, че не е добра идея да одобрявам инсталирането на пакети от buster
repo-то, защото доколкото разбирам използването на всякакви бинарки от там е забранено. Това не знам
дали значи, че всички dependency-та не трябва да са взети, като source пакети и инсталирани, като
backport-ове и чак тогава да инсталирам jabberd2. Понеже това ми изглежда мазохистично и силно
съмнително ще попрочета още и вероятно ще пробвам и с sbuild да направя build или поне да
проуча още малко как да си направя backport на ръка. Преди съм правил rpm пакет и доколкото знам
може и deb пакет да направя по сходен начин. Това обаче не знам дали е идеята. sbuild ми се струва,
като по-вероятен вариант. 

Сега осмислих, че повечето пакети, които има в buster repository-то трябва да ги има и в
stretch-backports и вероятно трябва да ги взема от там. Тогава е интересно, защо не ги намира.
Видях, че backports repo-то е деактивирано по подразбиране, което вероятно ми е проблема XD. Затова
ще се наложи да го активирам в sources.list по някакъв начин или да кажа на mk-build-deps да го
използва. Погледнах по-подробно mk-build-deps какво прави и ми се наложи да гугълна какво е equiv:
https://packages.debian.org/jessie/equivs Разбрах, че се използва за създаване на тривиални пакети,
съдържащи само dependency информация. Може да се и използва за правене и на стандартни deb пакети.
equivs се използва от mk-build-deps за генериране на пакети с dependency-та. Също, ако има проблеми
с някое dependency ти казва кое точно е проблемно още при генериране на пакета. Тоест пакета се
генерира дори dependency-то да липсва доколкото разбирам. Намерих начин с нещо наречено apt-pinning:
https://unix.stackexchange.com/questions/310222/how-to-tell-apt-to-use-the-latest-package-by-default/310259
Доколкото виждам дава на различни repo-та приоритет. Реших да прочета man page-а преди да продължа. 
Сетих се също така, че към момента имам проблем само с един пакет, който е debhelper и него го
инсталирах експлицитно от с -t. Сега ще видя дали ще ми се наложи да използвам pinning. Този път
build-deps си свърши работата и сработи за мое щастие :D.

Като следващата стъпка прочетох какво е fakeroot. Разбрах, че дава на non-root потребител достъп до
root команди за манипулиране на файлове в изолирана среда, така че всеки да може да създаде пакети
например. Това доколкото разбрах работи с chroot chmod и други подобни, които се използват за
създаването на средата. Пуснах debian/rules binary опцията, която доколкото разбирам пуска някакви
тестове и казва дали е възможно да се инсталира пакета. Гугълнах и видях тук, че е навързано това
с debhelper, който ми правеше проблеми:
https://www.debian.org/doc/manuals/debmake-doc/ch05.en.html#:~:text=The%20debian%2Frules%20script%20is,files%20as%20the%20deb%20file.
После прочетох man page-а на debhelper. Установих, че той се използва, за да помогне на debian
потребителите да си правят собствени пакети. Този debian/rules е скрипт, който служи за
автоматизиране на debianhelper команди за построяване на пакети. Буквално позволява да напишеш
няколко helper команди, така че да го пуснеш после и да ти построи пакета. Намерих и самия
debian/rules файл в source директорията и я разгледах да видя как изглежда. В него се рънва
dh_auto_install командата, която се опитва да инсталира debian пакета. Търси например make файла и
се опитва да пусне install target-а, т че да се инсталира програмата. Има и dh_auto_configure, което
общо взето се опитва автоматично да намери configure файла и да го пусна, като може да й се подадат
аргументи за различните configure опции. Съответно fakeroot пуска тези команди в изолирана среда и и
я стрива след получаване на резултат .fakeroot debian/rules командата не мина, което леко ме
притесни обаче грешките бяха странни. Някакви добълнителни скоби и проблеми в кода излизат
подчертани като грешки.  Цялостно се вгледах в грешката и видя, че рецептата за target binary се е
провалила. Цялостно още не съм сигурен какъв е този target. Видях, че има още няколко target-а в
deabian helper man page-а, но не видях подробности за какво са. Предполагама binary казва, че искам
да получа binary файл или да инсталирам пакета, но не съм сигурен. Реално разбрах, че ./configure
скрипта се проваля. Установих къде ми е проблема. mk-build-deps беше оставило генерирания deb пакет
и source-а беше все едно покварен и затова apt-source даваше грешка.  mk-build-deps му бях дал -i
флаговете и -r, които реално инсталират deb пакета и го изтриват след като той се генерира. Нещо
обаче -r флага не е бил сработил миналите пъти, като е имало проблеми или аз някой път съм прекратил
по-рано командата.  Това, което ми помогна да се усета беше този линк:
https://askubuntu.com/questions/434695/dpkg-source-unrepresentable-changes-to-source-when-trying-to-debuild-a-modifi
Съответно явно човека е имал проблем със скрити файлове. След като открих това и fakeroot
debian/rules мина успешно, реших да пусна вече пакета да се build-не с dpk-build-packages, да видя
дали ще е успешно. Преди това обаче реших да прегледам какво прави командата преди да я пускам. В
момента използвам простичкия вариант за правене на backport от страницата на debina(не знам дали
споменах по-рано). Ако остане време, ще тествам и другия, но бих искал да имам нещо работещо. Та да
се върнем на темата. Разгледах man page-а на dpkg-build-packages, за да разбера каквое прави и за
какво са -us и -uc флаговете. Флаговете разбрах, че маркират пакета, като unsigned source и usnigned
changes, което не би трябвало да е проблем. На самия man page, бяха описани и в 12 стъпки как точно
се build-ва пакета. Те съответно са:
1) Set-ване на Environment variables
2) Проверка за конфликит и dependency-та
3) debian/rules clean за почистването на build дървото.
4) Ако съм поискал source build се прави(.dsc файл)
5) Пуска build target на debian/rules и после fakeroot debian/rules binary таргета
6) buildinfo - генерира .buildinfo файл
7) Пуска changes hooks, които генерират .changes файл.
8) post-clean. Почиства temp файлове за build-ване
9) dpkg-source --after-build
10) check hook върху changes файл
11) sign hook за подписване и вика gpg gpg2 и buildinfo и changes файловете
12) done hook
И цялостно имам някаква интуитивна представа за какво са тези 12 стъпки, но още съм объркан.
Хубавото е, че термина hooks най-накрая ми помогна да намеря информация за каква е разликата между
binary, build и тем подобни на man page-а на debuild:
https://manpages.debian.org/testing/devscripts/debuild.1.en.html
Може би беше лоша идея, но пуснах командата за build-ване преди да инсталирам докрай и генерирах deb
пакета. После го инсталирах и сработи :D. Остана да допрочета точно какво прави debuild. Сървъра
както се очакваше не работи, но се инсталира и командите се намират.

Допълнително четене:
lintian: Видях, че това са static analysis tool за проверка дали пакети се придържат към debian
политиката и дали няма някакви грешки. .changes файлът се използва от lintian, за да се анализира
пакет. Може и диркетно deb файл да се подаде: https://manpages.debian.org/buster/lintian/lintian.1.en.html

debian package source tree - https://www.debian.org/doc/debian-policy/ap-pkg-sourcepkg#the-debian-package-source-tree
Това е просто оригиналната програма с допълнително файлове, за да се улесни процес на build-ване на
пакети. Част от това е debian директорията с debian/rules.

debian/control - съдържа метаданните за файла. Съответно версията, dependency-тата, конфликтите, кой
е създал пакета и още много.

debian - най-накрая сцепих за какво е debian директорията. Тя е цялостно само с информация нужна за
build-ване на пакета. Примерно съдържа информация какво да направим преди пускане започване на
инсталацията, къде да сложим различните файлове нужни на нашата програма, за да работи, какво да
правим след инсталация, като почистване и много други. Това мисля, че е аналог на rpmbuild
директорията при redhat.

debuild - https://manpages.debian.org/testing/devscripts/debuild.1.en.html
използва dpk-buildpackage, за да build-не пакет. Пуска lintian за static analysis и после използва
debsign, за да подпише пакета освен, ако не му се каже да не го прави. Може да му се подадат
hook-овете, споменати по-горе за аргументи и той да вика debian/rules с тях. Има вграден directory
name checking или с други думи използва debian/changelog файла, за да верифицира името на
директорията. Почиства environment variables преди да build-не, като оставя само жизненоважните.
Може и да не е това. Разбрах, че може да се генерира с debmake.

dpkg-source - https://man7.org/linux/man-pages/man1/dpkg-source.1.html
работа със dsc файлов. Манипулация на .dsc файлове. Този tool може да се използва за build-ването на
source пакети и тяхното разархивиране. Също така tool-а работи с commit-и идеята, на които е да
поддържат информацията за промените по source-tree-то. Това ми ревеше по-рано като имах останал файл
от mk-build-deps.

hooks - за жалост и в debuild не са описани точно какво правят, а само че са скриптове, които се
пускат в даден ред. На интуитивно ниво разбирам идеята, но съм дотам засега. Най-накрая в секцията
за debhelper на този линк: https://www.debian.org/doc/manuals/debmake-doc/ch05.en.html#dh
са описани. Не знам дали са същите, които се използват от dpkg-buildpackage, но мисля, че е доста
вероятно да са. build - прави build tree. clean - почиства build дървото, binary - прави deb пакет,
install - инсталира binary пакета и това мисля, че са основните. Най-накрая намерих нещо полезно:
https://www.debian.org/doc/debian-policy/ch-source.html#s-debianrules На горния линк вече всичките
са описани за какво са. Така официално clean трие файловете генерирани по време на генериране и
build-ване на deb файл. build изпълнява всичко команди, които не се нуждаят от root права, за да ни
подготви за това да пуснем binary, което генерира binary(deb) файл. Цялостно в линка за debian rules
има бая интересни неща, като формата за changelog, build options като паралелен build, което щеше да
е полезно, макар че не беше толкова бавно така или иначе. Цялостно съм поуморен вече и мисля, че
горе долу разбрах какво става. Не знам дали тези hook-ове се пишат от човека, който прави пакети.
Като гледам май не или поне не виждам къде точно са дефинирани, ама вече леко ми писна да ги търся.

apt-pinning: https://wiki.debian.org/AptConfiguration 
Както и предположих служи за промяна на приоритетите на repository-тата. Може да направиш едно да
се вика винаги преди останалите.


Време: 9 часа.
